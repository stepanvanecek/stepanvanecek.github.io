<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sys-sage: XML – Functionality</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sys-sage
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">XML – Functionality</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md48"></a></p>
<h1><a class="anchor" id="autotoc_md49"></a>
XML - Export</h1>
<div class="fragment"><div class="line">int exportToXml(Component *root, string path = &quot;&quot;, std::function&lt;int(string, void *, string *)&gt; search_custom_attrib_key_fcn = NULL, std::function&lt;int(string, void *, xmlNodePtr)&gt; search_custom_complex_attrib_key_fcn = NULL); </div>
</div><!-- fragment --><p>This function starts with the root component and exports the entire topology to an XML file, including the Datapaths, which are appended at the end of the file.</p>
<p>For attribute parsing, the function uses default parsing mechanisms if no custom functions are provided. The default parsing includes the following simple attributes:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key   </th><th class="markdownTableHeadNone">Value-Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CATcos   </td><td class="markdownTableBodyNone">uint64_t    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CATL3mask   </td><td class="markdownTableBodyNone">uint64_t    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mig_size   </td><td class="markdownTableBodyNone">long long    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Number_of_streaming_multiprocessors   </td><td class="markdownTableBodyNone">int    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number_of_cores_in_GPU   </td><td class="markdownTableBodyNone">int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Number_of_cores_per_SM   </td><td class="markdownTableBodyNone">int    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Bus_Width_bit   </td><td class="markdownTableBodyNone">int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Clock_Frequency   </td><td class="markdownTableBodyNone">double    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">latency   </td><td class="markdownTableBodyNone">float    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">latency_min   </td><td class="markdownTableBodyNone">float    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">latency_max   </td><td class="markdownTableBodyNone">float   </td></tr>
</table>
<p>For complex attributes the default function can parse the freq_history and GPU_Clock_Rate.</p>
<p>The freq_history might look like this in the resulting xml-file:</p>
<div class="fragment"><div class="line">&lt;Attribute name=&quot;freq_history&quot;&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045075772798&quot; frequency=&quot;3048.269000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045177185666&quot; frequency=&quot;800.000000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045278773648&quot; frequency=&quot;800.030000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045380334162&quot; frequency=&quot;800.001000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045482207012&quot; frequency=&quot;800.033000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045584019169&quot; frequency=&quot;800.009000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045685676789&quot; frequency=&quot;800.005000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045786759038&quot; frequency=&quot;1600.935000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045889138928&quot; frequency=&quot;800.012000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;freq_history timestamp=&quot;1736603045990249699&quot; frequency=&quot;2601.876000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">&lt;/Attribute&gt; </div>
</div><!-- fragment --><p>And for the GPU_Clock_Rate the xml-node will look like this</p>
<div class="fragment"><div class="line">&lt;Attribute name=&quot;GPU_Clock_Rate&quot;&gt; </div>
<div class="line"> </div>
<div class="line">    &lt;GPU_Clock_Rate frequency=&quot;3048.269000&quot; unit=&quot;MHz&quot;/&gt; </div>
<div class="line"> </div>
<div class="line">&lt;/Attribute&gt; </div>
</div><!-- fragment --><p>The Attribute-Nodes are all inserted as child-nodes under the corresponding Component-Node in the xml-file.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Custom Functions</h2>
<p>The XML Export function supports two optional custom functions, allowing users to customize the export process for both simple attributes and complex attributes.</p>
<p>Custom Function for Simple Attributes:\ If a custom function for simple attributes is provided, the export function forwards the key-value pair from the <code>attrib</code> map of the respective component to the custom function. The custom function is expected to return the processed value as a string, which will be written into the export as the provided ret_value_string (the last parameter of the custom function).</p>
<p>Such a function might look like this:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> search_simple(std::string k, <span class="keywordtype">void</span> *value, std::string *ret_value_str) {</div>
<div class="line">  <span class="comment">//check the key</span></div>
<div class="line">  <span class="keywordflow">if</span> (!k.compare(<span class="stringliteral">&quot;benchmark&quot;</span>)) {</div>
<div class="line">    <span class="comment">//process value to a string and store it</span></div>
<div class="line">    *ret_value_str = *(std::string *)value;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Custom Function for Complex Attributes:\ Similarly, for complex attributes, the export function forwards the key-value pair from the <code>attrib</code> map to the custom function. In addition, the current XML node is passed as a third parameter. Unlike the simple attributes, the custom function is responsible for directly writing the corresponding XML node(s) to the provided node.</p>
<p>One example of this kind of custom funcion is shown below: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> search_complex(std::string k, <span class="keywordtype">void</span> *value, xmlNodePtr n) {</div>
<div class="line">  <span class="comment">//check key</span></div>
<div class="line">  <span class="keywordflow">if</span> (!k.compare(<span class="stringliteral">&quot;complex&quot;</span>)) {</div>
<div class="line">    <span class="keywordtype">int</span> *val = (<span class="keywordtype">int</span> *)value;</div>
<div class="line">    <span class="comment">//create new xmlNode with &quot;Attribute&quot; as name</span></div>
<div class="line">    xmlNodePtr attr_node = xmlNewNode(NULL, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;Attribute&quot;</span>);</div>
<div class="line">    <span class="comment">//Assign the key given as argument</span></div>
<div class="line">    xmlNewProp(attr_node, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;key&quot;</span>,</div>
<div class="line">               (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)k.c_str());</div>
<div class="line">    <span class="comment">//Process the value to a string or use more xmlnodes if needed</span></div>
<div class="line">    xmlNewProp(attr_node, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;value&quot;</span>,</div>
<div class="line">               (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)std::to_string(*val).c_str());</div>
<div class="line">    xmlAddChild(n, attr_node);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The export tries to parse the attributes in this order:</p><ol type="1">
<li>custom_simple</li>
<li>default_simple</li>
<li>custom_complex</li>
<li>default_complex</li>
</ol>
<p>It will try each function in this order untill one function returns 1.</p>
<h1><a class="anchor" id="autotoc_md51"></a>
XML - Import</h1>
<div class="fragment"><div class="line">Component* importFromXml(string path, std::function&lt;void*(xmlNodePtr)&gt; search_custom_attrib_key_fcn = NULL, std::function&lt;int(xmlNodePtr, Component*)&gt; search_custom_complex_attrib_key_fcn = NULL);</div>
</div><!-- fragment --><p>The Import of xml-files works similiar to the export but in the opposite direction. It reads the xml-file with the same structure as the xml-export-files and returns the topology node. All the Datapaths and attributes are also stored after import.</p>
<p>The Attributes are stored in the attrib map of the components. Per default all the attribute types that can be parsed in the export can also be parsed in import.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Custom Functions</h2>
<p>Simple Attributes:\ For simple attributes, the corresponding attribute node from the XML file is forwarded to the custom function. The custom function is expected to produce a <code>void*</code> that can then be stored in the <code>attrib</code> map of the component.</p>
<p>Here is an example of how to define such a function: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> *imp_search_simple(xmlNodePtr n) {</div>
<div class="line">  <span class="comment">//check existence of key-value-pair</span></div>
<div class="line">  <span class="keywordflow">if</span> (xmlHasProp(n, (<span class="keyword">const</span> xmlChar *)<span class="stringliteral">&quot;name&quot;</span>) &amp;&amp;</div>
<div class="line">      xmlHasProp(n, (<span class="keyword">const</span> xmlChar *)<span class="stringliteral">&quot;value&quot;</span>)) {</div>
<div class="line">    <span class="comment">//retrieve key</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *v = xmlGetProp(n, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">    std::string key(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(v));</div>
<div class="line">    <span class="comment">//retrieve value</span></div>
<div class="line">    v = xmlGetProp(n, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line">    std::string value(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(v));</div>
<div class="line">    <span class="comment">//return value (key is already known by caller function)</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> std::string(value);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Complex Attributes:\ For complex attributes, the attribute node is forwarded alongside the current component. This allows the custom function to access the component’s <code>attrib</code> map and store the parsed attributes directly.</p>
<p>Defining a custom parsing function might look like this </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> imp_search_complex(xmlNodePtr n, Component *c) {</div>
<div class="line">  <span class="comment">//check existence of key-value-pair</span></div>
<div class="line">  <span class="keywordflow">if</span> (xmlHasProp(n, (<span class="keyword">const</span> xmlChar *)<span class="stringliteral">&quot;key&quot;</span>) &amp;&amp;</div>
<div class="line">      xmlHasProp(n, (<span class="keyword">const</span> xmlChar *)<span class="stringliteral">&quot;value&quot;</span>)) {</div>
<div class="line">    <span class="comment">//retrieve key</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *v = xmlGetProp(n, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">    std::string key(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(v));</div>
<div class="line">    <span class="comment">//retrieve value</span></div>
<div class="line">    v = xmlGetProp(n, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line">    <span class="keywordtype">int</span>* value = <span class="keyword">new</span> int(std::stoi(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(v)));</div>
<div class="line">    <span class="comment">//store value in component&#39;s attrib map</span></div>
<div class="line">    c-&gt;attrib[key] = (<span class="keywordtype">void</span>*) value;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While traversing XML nodes, it may be necessary to skip text nodes to avoid processing unintended data. For example: </p><div class="fragment"><div class="line">if (xml_node-&gt;type == XML_TEXT_NODE)</div>
<div class="line">    continue;</div>
</div><!-- fragment --><p> The custom function for complex attributes should return 1 on success and 0 on failure. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
