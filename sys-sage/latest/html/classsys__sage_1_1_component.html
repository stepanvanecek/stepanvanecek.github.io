<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sys-sage: sys_sage::Component Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sys-sage
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sys_sage</b></li><li class="navelem"><a class="el" href="classsys__sage_1_1_component.html">Component</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsys__sage_1_1_component-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sys_sage::Component Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Generic class for all hardware and logical components in sys-sage.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_component_8hpp_source.html">Component.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sys_sage::Component:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsys__sage_1_1_component.png" usemap="#sys_5Fsage::Component_map" alt=""/>
  <map id="sys_5Fsage::Component_map" name="sys_5Fsage::Component_map">
<area href="classsys__sage_1_1_cache.html" title="Represents a data cache in the system (of different levels/purposes)." alt="sys_sage::Cache" shape="rect" coords="180,56,350,80"/>
<area href="classsys__sage_1_1_chip.html" title="Represents a building block of a node (CPU socket, GPU, NIC, etc.)." alt="sys_sage::Chip" shape="rect" coords="180,112,350,136"/>
<area href="classsys__sage_1_1_core.html" alt="sys_sage::Core" shape="rect" coords="180,168,350,192"/>
<area href="classsys__sage_1_1_memory.html" alt="sys_sage::Memory" shape="rect" coords="180,224,350,248"/>
<area href="classsys__sage_1_1_node.html" alt="sys_sage::Node" shape="rect" coords="180,280,350,304"/>
<area href="classsys__sage_1_1_quantum_backend.html" title="Represents a quantum backend device (e.g., quantum processor or simulator)." alt="sys_sage::QuantumBackend" shape="rect" coords="180,336,350,360"/>
<area href="classsys__sage_1_1_qubit.html" title="Represents a physical or logical qubit in a quantum backend." alt="sys_sage::Qubit" shape="rect" coords="180,392,350,416"/>
<area href="classsys__sage_1_1_storage.html" alt="sys_sage::Storage" shape="rect" coords="180,448,350,472"/>
<area href="classsys__sage_1_1_subdivision.html" alt="sys_sage::Subdivision" shape="rect" coords="180,504,350,528"/>
<area href="classsys__sage_1_1_thread.html" alt="sys_sage::Thread" shape="rect" coords="180,560,350,584"/>
<area href="classsys__sage_1_1_topology.html" alt="sys_sage::Topology" shape="rect" coords="180,616,350,640"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b88f9dcdd64b7621d969642a1e7b4a1" id="r_a7b88f9dcdd64b7621d969642a1e7b4a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b88f9dcdd64b7621d969642a1e7b4a1">Component</a> (int _id=0, std::string _name=&quot;unknown&quot;)</td></tr>
<tr class="memdesc:a7b88f9dcdd64b7621d969642a1e7b4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> constructor (no automatic insertion in the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree). Usually one of the derived subclasses for different <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Types will be created, not this one.  <br /></td></tr>
<tr class="separator:a7b88f9dcdd64b7621d969642a1e7b4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc011565236186c83106770e789d454b" id="r_adc011565236186c83106770e789d454b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc011565236186c83106770e789d454b">Component</a> (<a class="el" href="classsys__sage_1_1_component.html">Component</a> *<a class="el" href="#abe38040d7626abb1b8dd89843fde1797">parent</a>, int _id=0, std::string _name=&quot;unknown&quot;)</td></tr>
<tr class="memdesc:adc011565236186c83106770e789d454b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> constructor with insertion into the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree as the parent's child. Usually one of the derived subclasses for different <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Types will be created.  <br /></td></tr>
<tr class="separator:adc011565236186c83106770e789d454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5934196560dc1ff0fcbb349d45bb86" id="r_a7b5934196560dc1ff0fcbb349d45bb86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b5934196560dc1ff0fcbb349d45bb86">InsertChild</a> (<a class="el" href="classsys__sage_1_1_component.html">Component</a> *child)</td></tr>
<tr class="memdesc:a7b5934196560dc1ff0fcbb349d45bb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a child component to this component (in the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree). The child pointer will be inserted at the end of the children vector.  <br /></td></tr>
<tr class="separator:a7b5934196560dc1ff0fcbb349d45bb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b71ad4e6174cd97e47eb778c51f94" id="r_aeb0b71ad4e6174cd97e47eb778c51f94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb0b71ad4e6174cd97e47eb778c51f94">InsertBetweenParentAndChild</a> (<a class="el" href="classsys__sage_1_1_component.html">Component</a> *<a class="el" href="#abe38040d7626abb1b8dd89843fde1797">parent</a>, <a class="el" href="classsys__sage_1_1_component.html">Component</a> *child, bool alreadyParentsChild)</td></tr>
<tr class="memdesc:aeb0b71ad4e6174cd97e47eb778c51f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts this component between a parent and one of its children. The parent component remains the parent, this <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> becomes a new child of the parent, and the specified child becomes this component's child.  <br /></td></tr>
<tr class="separator:aeb0b71ad4e6174cd97e47eb778c51f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d49c3a64ecc683d09402a6430ae766" id="r_a69d49c3a64ecc683d09402a6430ae766"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69d49c3a64ecc683d09402a6430ae766">InsertBetweenParentAndChildren</a> (<a class="el" href="classsys__sage_1_1_component.html">Component</a> *<a class="el" href="#abe38040d7626abb1b8dd89843fde1797">parent</a>, std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; <a class="el" href="#a70ebe24dfab4cbbfe29da9b0325e6c75">children</a>, bool alreadyParentsChild)</td></tr>
<tr class="memdesc:a69d49c3a64ecc683d09402a6430ae766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts this component between a parent and a (subset of) its children. The parent component remains parent, this <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> becomes a new child, and the children become parent's grandchildren.  <br /></td></tr>
<tr class="separator:a69d49c3a64ecc683d09402a6430ae766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0977347b3cff754daa6e3928a60d7409" id="r_a0977347b3cff754daa6e3928a60d7409"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0977347b3cff754daa6e3928a60d7409">RemoveChild</a> (<a class="el" href="classsys__sage_1_1_component.html">Component</a> *child)</td></tr>
<tr class="memdesc:a0977347b3cff754daa6e3928a60d7409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the passed component from the list of children, without completely deleting (and deallocating) the child itself.  <br /></td></tr>
<tr class="separator:a0977347b3cff754daa6e3928a60d7409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c3ddae6f20f000f711d4354cf5f0e2" id="r_a80c3ddae6f20f000f711d4354cf5f0e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c3ddae6f20f000f711d4354cf5f0e2">SetParent</a> (<a class="el" href="classsys__sage_1_1_component.html">Component</a> *<a class="el" href="#abe38040d7626abb1b8dd89843fde1797">parent</a>)</td></tr>
<tr class="memdesc:a80c3ddae6f20f000f711d4354cf5f0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a parent to the component. This is usually used when inserting a component in the tree (by calling InsertChild on the parent, and calling SetParent on the child).  <br /></td></tr>
<tr class="separator:a80c3ddae6f20f000f711d4354cf5f0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6e13a6635cace706df56256d80e61c" id="r_afc6e13a6635cace706df56256d80e61c"><td class="memItemLeft" align="right" valign="top"><a id="afc6e13a6635cace706df56256d80e61c" name="afc6e13a6635cace706df56256d80e61c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintSubtree</b> () const</td></tr>
<tr class="memdesc:afc6e13a6635cace706df56256d80e61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the whole subtree of this component (including the component itself) to stdout. The tree is printed in DFS order, so that the hierarchy can be easily seen. Each child is indented by "  ". For each component in the subtree, the following is printed: "&lt;string component type&gt; (name &lt;name&gt;) id &lt;id&gt; - children: &lt;num children&gt; <br /></td></tr>
<tr class="separator:afc6e13a6635cace706df56256d80e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d200089dabc30e3045c4711928a0e7" id="r_a78d200089dabc30e3045c4711928a0e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78d200089dabc30e3045c4711928a0e7">PrintAllDataPathsInSubtree</a> ()</td></tr>
<tr class="memdesc:a78d200089dabc30e3045c4711928a0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all DataPaths that go from or to components in the subtree.  <br /></td></tr>
<tr class="separator:a78d200089dabc30e3045c4711928a0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e254ca10e0fadfcccd32e7d48566b08" id="r_a7e254ca10e0fadfcccd32e7d48566b08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e254ca10e0fadfcccd32e7d48566b08">PrintAllRelationsInSubtree</a> (RelationType::type RelationType=RelationType::Any)</td></tr>
<tr class="memdesc:a7e254ca10e0fadfcccd32e7d48566b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all Relations in the subtree.  <br /></td></tr>
<tr class="separator:a7e254ca10e0fadfcccd32e7d48566b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571e19ef662f6854e511f514251198e9" id="r_a571e19ef662f6854e511f514251198e9"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a571e19ef662f6854e511f514251198e9">GetName</a> () const</td></tr>
<tr class="memdesc:a571e19ef662f6854e511f514251198e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name of the component.  <br /></td></tr>
<tr class="separator:a571e19ef662f6854e511f514251198e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14104ef976caf0fecf60b7f6a747152" id="r_ac14104ef976caf0fecf60b7f6a747152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14104ef976caf0fecf60b7f6a747152">SetName</a> (std::string _name)</td></tr>
<tr class="memdesc:ac14104ef976caf0fecf60b7f6a747152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets name of the component.  <br /></td></tr>
<tr class="separator:ac14104ef976caf0fecf60b7f6a747152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5dd63767b1099de90f4f4f58024202" id="r_afe5dd63767b1099de90f4f4f58024202"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe5dd63767b1099de90f4f4f58024202">GetId</a> () const</td></tr>
<tr class="memdesc:afe5dd63767b1099de90f4f4f58024202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns id of the component.  <br /></td></tr>
<tr class="separator:afe5dd63767b1099de90f4f4f58024202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2e003475f48a9b717c441fb592dd19" id="r_a3d2e003475f48a9b717c441fb592dd19"><td class="memItemLeft" align="right" valign="top">sys_sage::ComponentType::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d2e003475f48a9b717c441fb592dd19">GetComponentType</a> () const</td></tr>
<tr class="memdesc:a3d2e003475f48a9b717c441fb592dd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns component type of the component. The component type denotes which class the instance is (often stored as Component*, even though they are a member of one of the child classes).  <br /></td></tr>
<tr class="separator:a3d2e003475f48a9b717c441fb592dd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606533d6eb18de70c51d8ca6cc0c3cd8" id="r_a606533d6eb18de70c51d8ca6cc0c3cd8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a606533d6eb18de70c51d8ca6cc0c3cd8">GetComponentTypeStr</a> () const</td></tr>
<tr class="memdesc:a606533d6eb18de70c51d8ca6cc0c3cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns component type as a human-readable string, as defined in ComponentType::names.  <br /></td></tr>
<tr class="separator:a606533d6eb18de70c51d8ca6cc0c3cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102573e48304e787ee8920fc419f8255" id="r_a102573e48304e787ee8920fc419f8255"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a102573e48304e787ee8920fc419f8255">GetChildren</a> () const</td></tr>
<tr class="memdesc:a102573e48304e787ee8920fc419f8255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to std::vector containing all children of the component (empty vector if no children).  <br /></td></tr>
<tr class="separator:a102573e48304e787ee8920fc419f8255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ec5de1ef8265eeaf5c7df2caf682f1" id="r_a01ec5de1ef8265eeaf5c7df2caf682f1"><td class="memItemLeft" align="right" valign="top"><a id="a01ec5de1ef8265eeaf5c7df2caf682f1" name="a01ec5de1ef8265eeaf5c7df2caf682f1"></a>
<a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetParent</b> () const</td></tr>
<tr class="memdesc:a01ec5de1ef8265eeaf5c7df2caf682f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointer to parent (or NULL if this component is the root) <br /></td></tr>
<tr class="separator:a01ec5de1ef8265eeaf5c7df2caf682f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cee810e3f609347034bd398d87ca29" id="r_a40cee810e3f609347034bd398d87ca29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40cee810e3f609347034bd398d87ca29">GetChild</a> (int _id) const</td></tr>
<tr class="memdesc:a40cee810e3f609347034bd398d87ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a Component* to a child with child.id=_id. Identical to GetChildById <br  />
 Should there be more children with the same id, the first match will be retrieved (i.e. the one with lower index in the children array.)  <br /></td></tr>
<tr class="separator:a40cee810e3f609347034bd398d87ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f5d098e80c3c90f9c2869838f1034b" id="r_a93f5d098e80c3c90f9c2869838f1034b"><td class="memItemLeft" align="right" valign="top"><a id="a93f5d098e80c3c90f9c2869838f1034b" name="a93f5d098e80c3c90f9c2869838f1034b"></a>
<a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetChildById</b> (int _id) const</td></tr>
<tr class="memdesc:a93f5d098e80c3c90f9c2869838f1034b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a Component* to a child with child.id=_id. Should there be more children with the same id, the first match will be retrieved (i.e. the one with lower index in the children array.) <br /></td></tr>
<tr class="separator:a93f5d098e80c3c90f9c2869838f1034b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b6fa0489f5c3b97ed636a4ec285dfe" id="r_a78b6fa0489f5c3b97ed636a4ec285dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78b6fa0489f5c3b97ed636a4ec285dfe">GetChildByType</a> (ComponentType::type _componentType) const</td></tr>
<tr class="memdesc:a78b6fa0489f5c3b97ed636a4ec285dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a Component* to a child matching the given component type. Should there be more children with the same type, the first match will be retrieved (i.e. the one with lower index in the children array.)  <br /></td></tr>
<tr class="separator:a78b6fa0489f5c3b97ed636a4ec285dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18783dfe98dc27be1a556cab90d99b87" id="r_a18783dfe98dc27be1a556cab90d99b87"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18783dfe98dc27be1a556cab90d99b87">GetAllChildrenByType</a> (ComponentType::type _componentType) const</td></tr>
<tr class="memdesc:a18783dfe98dc27be1a556cab90d99b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for all children matching the given component type.  <br /></td></tr>
<tr class="separator:a18783dfe98dc27be1a556cab90d99b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618d16b87006b900f873456ee179c0e4" id="r_a618d16b87006b900f873456ee179c0e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a618d16b87006b900f873456ee179c0e4">GetAllChildrenByType</a> (std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *_outArray, ComponentType::type _componentType) const</td></tr>
<tr class="memdesc:a618d16b87006b900f873456ee179c0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for all the children matching the given component type.  <br /></td></tr>
<tr class="separator:a618d16b87006b900f873456ee179c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbecea49599fba84e09700818acf3476" id="r_adbecea49599fba84e09700818acf3476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbecea49599fba84e09700818acf3476">GetSubcomponentById</a> (int _id, ComponentType::type _componentType)</td></tr>
<tr class="memdesc:adbecea49599fba84e09700818acf3476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the subtree to find a component with a matching id and componentType, i.e. looks for a certain component with a matching ID. The search is a DFS. The search starts with the calling component.  <br /></td></tr>
<tr class="separator:adbecea49599fba84e09700818acf3476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a428eeef0ff87ab5cdd1ff4bc4cc128" id="r_a3a428eeef0ff87ab5cdd1ff4bc4cc128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a428eeef0ff87ab5cdd1ff4bc4cc128">GetAllSubcomponentsByType</a> (std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *outArray, ComponentType::type _componentType)</td></tr>
<tr class="memdesc:a3a428eeef0ff87ab5cdd1ff4bc4cc128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for all the subcomponents (children, their children and so on) matching the given component type.  <br /></td></tr>
<tr class="separator:a3a428eeef0ff87ab5cdd1ff4bc4cc128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b43f386c4534fb4c15ac60fe465359" id="r_a96b43f386c4534fb4c15ac60fe465359"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b43f386c4534fb4c15ac60fe465359">GetAllSubcomponentsByType</a> (ComponentType::type _componentType)</td></tr>
<tr class="memdesc:a96b43f386c4534fb4c15ac60fe465359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for all the subcomponents (children, their children and so on) matching the given component type.  <br /></td></tr>
<tr class="separator:a96b43f386c4534fb4c15ac60fe465359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adf18964122974506a626022e510472" id="r_a2adf18964122974506a626022e510472"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2adf18964122974506a626022e510472">CountAllSubcomponents</a> () const</td></tr>
<tr class="memdesc:a2adf18964122974506a626022e510472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of subcomponents (children, grandchildren, etc.).  <br /></td></tr>
<tr class="separator:a2adf18964122974506a626022e510472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d642e68a8be377dbba51469599e6893" id="r_a0d642e68a8be377dbba51469599e6893"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d642e68a8be377dbba51469599e6893">CountAllSubcomponentsByType</a> (ComponentType::type _componentType) const</td></tr>
<tr class="memdesc:a0d642e68a8be377dbba51469599e6893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of subcomponents (children, their children and so on) matching the requested component type.  <br /></td></tr>
<tr class="separator:a0d642e68a8be377dbba51469599e6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3d9b9cf3391c9f23b5228477c9c072" id="r_a5a3d9b9cf3391c9f23b5228477c9c072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a3d9b9cf3391c9f23b5228477c9c072">CountAllChildrenByType</a> (ComponentType::type _componentType) const</td></tr>
<tr class="memdesc:a5a3d9b9cf3391c9f23b5228477c9c072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of children matching the requested component type.  <br /></td></tr>
<tr class="separator:a5a3d9b9cf3391c9f23b5228477c9c072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d09a836476b9076fb70cd52ee055059" id="r_a0d09a836476b9076fb70cd52ee055059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d09a836476b9076fb70cd52ee055059">GetAncestorByType</a> (ComponentType::type _componentType)</td></tr>
<tr class="memdesc:a0d09a836476b9076fb70cd52ee055059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves up the tree until a parent of the given type is found.  <br /></td></tr>
<tr class="separator:a0d09a836476b9076fb70cd52ee055059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95564c43b5f7ffb6255bc85b95e9e1b0" id="r_a95564c43b5f7ffb6255bc85b95e9e1b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95564c43b5f7ffb6255bc85b95e9e1b0">GetSubtreeDepth</a> () const</td></tr>
<tr class="memdesc:a95564c43b5f7ffb6255bc85b95e9e1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves maximal distance to a leaf (i.e. the depth of the subtree). 0=leaf, 1=children are leaves, 2=at most children's children are leaves .....  <br /></td></tr>
<tr class="separator:a95564c43b5f7ffb6255bc85b95e9e1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ad84ea937833249a7dc5f90c20dae1" id="r_a83ad84ea937833249a7dc5f90c20dae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83ad84ea937833249a7dc5f90c20dae1">GetNthAncestor</a> (int n)</td></tr>
<tr class="memdesc:a83ad84ea937833249a7dc5f90c20dae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves Nth ancestor, which resides N levels above. E.g. if n=1, the parent is retrieved; if n=2, the grandparent is retrieved and so on.  <br /></td></tr>
<tr class="separator:a83ad84ea937833249a7dc5f90c20dae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c18e4f1393f04444cada28b3845499" id="r_a55c18e4f1393f04444cada28b3845499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55c18e4f1393f04444cada28b3845499">GetNthDescendents</a> (std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *outArray, int <a class="el" href="#a766867133d2273ceb287637583138101">depth</a>)</td></tr>
<tr class="memdesc:a55c18e4f1393f04444cada28b3845499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside 'depth' levels deeper. The tree is traversed in order as the children are stored in std::vector children. E.g. if depth=1, only children of the current are retrieved; if depth=2, only children of the children are retrieved..  <br /></td></tr>
<tr class="separator:a55c18e4f1393f04444cada28b3845499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7c5a5bc47f5d0e0154320a61c9d4a5" id="r_aaa7c5a5bc47f5d0e0154320a61c9d4a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa7c5a5bc47f5d0e0154320a61c9d4a5">GetNthDescendents</a> (int <a class="el" href="#a766867133d2273ceb287637583138101">depth</a>)</td></tr>
<tr class="memdesc:aaa7c5a5bc47f5d0e0154320a61c9d4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside 'depth' levels deeper. The tree is traversed in order as the children are stored in the std::vector. E.g. if depth=1, only children of the current are retrieved; if depth=2, only children of the children are retrieved..  <br /></td></tr>
<tr class="separator:aaa7c5a5bc47f5d0e0154320a61c9d4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2581cf51ba958d2319f7c2c00cd4cac5" id="r_a2581cf51ba958d2319f7c2c00cd4cac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2581cf51ba958d2319f7c2c00cd4cac5">GetSubcomponentsByType</a> (std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *outArray, ComponentType::type <a class="el" href="#a219aacfb50e3025ac4bfe1c3236c1d34">componentType</a>)</td></tr>
<tr class="memdesc:a2581cf51ba958d2319f7c2c00cd4cac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside in the subtree and have a matching type. The tree is traversed DFS in order as the children are stored in each std::vector children.  <br /></td></tr>
<tr class="separator:a2581cf51ba958d2319f7c2c00cd4cac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b2d9ae8b2188938995a208f00834c4" id="r_ad8b2d9ae8b2188938995a208f00834c4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b2d9ae8b2188938995a208f00834c4">GetSubcomponentsByType</a> (ComponentType::type _componentType)</td></tr>
<tr class="memdesc:ad8b2d9ae8b2188938995a208f00834c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside in the subtree and have a matching type. The tree is traversed DFS in order as the children are stored in the std::vector.  <br /></td></tr>
<tr class="separator:ad8b2d9ae8b2188938995a208f00834c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf88f6d2e0bd8f5e1ed151e640c304ad" id="r_acf88f6d2e0bd8f5e1ed151e640c304ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf88f6d2e0bd8f5e1ed151e640c304ad">GetComponentsInSubtree</a> (std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *outArray)</td></tr>
<tr class="memdesc:acf88f6d2e0bd8f5e1ed151e640c304ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which form the subtree (current node and all the subcomponents) of this.  <br /></td></tr>
<tr class="separator:acf88f6d2e0bd8f5e1ed151e640c304ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be4d6bed7f70dfdd9d522a0c78710d" id="r_ad0be4d6bed7f70dfdd9d522a0c78710d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0be4d6bed7f70dfdd9d522a0c78710d">GetComponentsInSubtree</a> ()</td></tr>
<tr class="memdesc:ad0be4d6bed7f70dfdd9d522a0c78710d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which form the subtree (current node and all the subcomponents) of this.  <br /></td></tr>
<tr class="separator:ad0be4d6bed7f70dfdd9d522a0c78710d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912206e825439c92a7f19b9b58c06dc7" id="r_a912206e825439c92a7f19b9b58c06dc7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classsys__sage_1_1_relation.html">Relation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a912206e825439c92a7f19b9b58c06dc7">GetRelations</a> (RelationType::type relationType) const</td></tr>
<tr class="memdesc:a912206e825439c92a7f19b9b58c06dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (const) reference to the internal vector of relations for a given type.  <br /></td></tr>
<tr class="separator:a912206e825439c92a7f19b9b58c06dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e60583790bdc02d85b54333c7a7bfd" id="r_ac6e60583790bdc02d85b54333c7a7bfd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_relation.html">Relation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6e60583790bdc02d85b54333c7a7bfd">GetAllRelationsBy</a> (RelationType::type relationType=RelationType::Any, int thisComponentPosition=-1) const</td></tr>
<tr class="memdesc:ac6e60583790bdc02d85b54333c7a7bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly-constructed vector of all relations of a given type and position.  <br /></td></tr>
<tr class="separator:ac6e60583790bdc02d85b54333c7a7bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d8add279b57e243f8dc4e12f8a2646" id="r_a45d8add279b57e243f8dc4e12f8a2646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsys__sage_1_1_data_path.html">DataPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45d8add279b57e243f8dc4e12f8a2646">GetDataPathByType</a> (DataPathType::type dp_type, DataPathDirection::type direction=DataPathDirection::Any) const</td></tr>
<tr class="memdesc:a45d8add279b57e243f8dc4e12f8a2646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a DataPath* from the list of this component's data paths with matching <a class="el" href="namespace_data_path_type.html" title="Enumerates types of DataPaths (logical, physical, etc.).">DataPathType</a> and <a class="el" href="namespace_data_path_direction.html" title="Enumerates directionality for DataPaths.">DataPathDirection</a>. The first match is returned.  <br /></td></tr>
<tr class="separator:a45d8add279b57e243f8dc4e12f8a2646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03568c03fc078afb105a70263a247dde" id="r_a03568c03fc078afb105a70263a247dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03568c03fc078afb105a70263a247dde">GetAllDataPaths</a> (std::vector&lt; <a class="el" href="classsys__sage_1_1_data_path.html">DataPath</a> * &gt; *outDpArr, DataPathType::type dp_type=DataPathType::Any, DataPathDirection::type direction=DataPathDirection::Any) const</td></tr>
<tr class="memdesc:a03568c03fc078afb105a70263a247dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all DataPath* from the list of this component's data paths with matching type and orientation. Results are returned in std::vector&lt;DataPath*&gt;* outDpArr, where first the matching data paths in dp_outgoing are pushed back, then the ones in dp_incoming.  <br /></td></tr>
<tr class="separator:a03568c03fc078afb105a70263a247dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7937e5e8ef77443b88dae67a42eb80b" id="r_aa7937e5e8ef77443b88dae67a42eb80b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_data_path.html">DataPath</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7937e5e8ef77443b88dae67a42eb80b">GetAllDataPaths</a> (DataPathType::type dp_type=DataPathType::Any, DataPathDirection::type direction=DataPathDirection::Any) const</td></tr>
<tr class="memdesc:aa7937e5e8ef77443b88dae67a42eb80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all DataPath* from the list of this component's data paths with matching type and orientation/direction. Results are returned in a std::vector&lt;DataPath*&gt;*.  <br /></td></tr>
<tr class="separator:aa7937e5e8ef77443b88dae67a42eb80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fce4641fa6a741668f0ba02fe72e15" id="r_a84fce4641fa6a741668f0ba02fe72e15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84fce4641fa6a741668f0ba02fe72e15">CheckComponentTreeConsistency</a> () const</td></tr>
<tr class="memdesc:a84fce4641fa6a741668f0ba02fe72e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the consistency of the component tree starting from this component.  <br /></td></tr>
<tr class="separator:a84fce4641fa6a741668f0ba02fe72e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd63a616e51fb087826b818e43f4c0e1" id="r_acd63a616e51fb087826b818e43f4c0e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd63a616e51fb087826b818e43f4c0e1">GetTopologySize</a> (unsigned *out_component_size, unsigned *out_dataPathSize) const</td></tr>
<tr class="memdesc:acd63a616e51fb087826b818e43f4c0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates approximate memory footprint of the subtree of this element (including the relevant Relations).  <br /></td></tr>
<tr class="separator:acd63a616e51fb087826b818e43f4c0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2f25a7b4f370bcb071f4ad9cc689a5" id="r_aff2f25a7b4f370bcb071f4ad9cc689a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2f25a7b4f370bcb071f4ad9cc689a5">GetDepth</a> (bool refresh)</td></tr>
<tr class="memdesc:aff2f25a7b4f370bcb071f4ad9cc689a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the depth (level) of a component in the topology.  <br /></td></tr>
<tr class="separator:aff2f25a7b4f370bcb071f4ad9cc689a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b4efc89591b330695021079b029a19" id="r_a56b4efc89591b330695021079b029a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56b4efc89591b330695021079b029a19">DeleteRelation</a> (<a class="el" href="classsys__sage_1_1_relation.html">Relation</a> *r)</td></tr>
<tr class="memdesc:a56b4efc89591b330695021079b029a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a <a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">Relation</a> from this component as well as the <a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">Relation</a> itself.  <br /></td></tr>
<tr class="separator:a56b4efc89591b330695021079b029a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1728d7de6b379d7e32c0d302a468ef9" id="r_ad1728d7de6b379d7e32c0d302a468ef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1728d7de6b379d7e32c0d302a468ef9">DeleteDataPath</a> (<a class="el" href="classsys__sage_1_1_data_path.html">DataPath</a> *dp)</td></tr>
<tr class="memdesc:ad1728d7de6b379d7e32c0d302a468ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes and deallocates the <a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a> pointer from the list of outgoing/incoming DataPaths.  <br /></td></tr>
<tr class="separator:ad1728d7de6b379d7e32c0d302a468ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28f751289bc49b18cb716c625e8e944" id="r_aa28f751289bc49b18cb716c625e8e944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28f751289bc49b18cb716c625e8e944">DeleteAllRelations</a> (RelationType::type relationType=RelationType::Any)</td></tr>
<tr class="memdesc:aa28f751289bc49b18cb716c625e8e944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all relations of this component (optionally filtered by type).  <br /></td></tr>
<tr class="separator:aa28f751289bc49b18cb716c625e8e944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1585090f3d99a344e663d36a9eef6e" id="r_a0a1585090f3d99a344e663d36a9eef6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a1585090f3d99a344e663d36a9eef6e">DeleteAllDataPaths</a> ()</td></tr>
<tr class="memdesc:a0a1585090f3d99a344e663d36a9eef6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all DataPaths of this component.  <br /></td></tr>
<tr class="separator:a0a1585090f3d99a344e663d36a9eef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61b2467f1b0207a50ce2e5dce7b9a05" id="r_ae61b2467f1b0207a50ce2e5dce7b9a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61b2467f1b0207a50ce2e5dce7b9a05">DeleteSubtree</a> () const</td></tr>
<tr class="separator:ae61b2467f1b0207a50ce2e5dce7b9a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f18c9b1fab65c52467804d4051e3f01" id="r_a8f18c9b1fab65c52467804d4051e3f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f18c9b1fab65c52467804d4051e3f01">Delete</a> (bool withSubtree=true)</td></tr>
<tr class="memdesc:a8f18c9b1fab65c52467804d4051e3f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a component, its children (if withSubtree = true), and all associated Relations. If only the component itself is deleted, its children are inserted into its parent's children list.  <br /></td></tr>
<tr class="separator:a8f18c9b1fab65c52467804d4051e3f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0f6118c4deef5da3aa3e624322a5d604" id="r_a0f6118c4deef5da3aa3e624322a5d604"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a></td></tr>
<tr class="separator:a0f6118c4deef5da3aa3e624322a5d604"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5151f3f53a35acf43c4f0717d88ee68a" id="r_a5151f3f53a35acf43c4f0717d88ee68a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5151f3f53a35acf43c4f0717d88ee68a">Component</a> (int _id, std::string _name, ComponentType::type _componentType)</td></tr>
<tr class="memdesc:a5151f3f53a35acf43c4f0717d88ee68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected constructor for derived classes (no automatic insertion in the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree).  <br /></td></tr>
<tr class="separator:a5151f3f53a35acf43c4f0717d88ee68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4470d24dbac731175ce1f1cf51ed4d94" id="r_a4470d24dbac731175ce1f1cf51ed4d94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4470d24dbac731175ce1f1cf51ed4d94">Component</a> (<a class="el" href="classsys__sage_1_1_component.html">Component</a> *<a class="el" href="#abe38040d7626abb1b8dd89843fde1797">parent</a>, int _id, std::string _name, ComponentType::type _componentType)</td></tr>
<tr class="memdesc:a4470d24dbac731175ce1f1cf51ed4d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected constructor for derived classes with insertion into the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree.  <br /></td></tr>
<tr class="separator:a4470d24dbac731175ce1f1cf51ed4d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a754d00f6d7541f59961815e4119ac7fe" id="r_a754d00f6d7541f59961815e4119ac7fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a754d00f6d7541f59961815e4119ac7fe">id</a></td></tr>
<tr class="separator:a754d00f6d7541f59961815e4119ac7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766867133d2273ceb287637583138101" id="r_a766867133d2273ceb287637583138101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a766867133d2273ceb287637583138101">depth</a></td></tr>
<tr class="separator:a766867133d2273ceb287637583138101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8228f2c1fc33fd4507cb4ff1cd91fc" id="r_a7f8228f2c1fc33fd4507cb4ff1cd91fc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f8228f2c1fc33fd4507cb4ff1cd91fc">name</a></td></tr>
<tr class="separator:a7f8228f2c1fc33fd4507cb4ff1cd91fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d4d19be7e780cf2e9a4a88fcd4b5b0" id="r_a06d4d19be7e780cf2e9a4a88fcd4b5b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d4d19be7e780cf2e9a4a88fcd4b5b0">count</a> {-1}</td></tr>
<tr class="separator:a06d4d19be7e780cf2e9a4a88fcd4b5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219aacfb50e3025ac4bfe1c3236c1d34" id="r_a219aacfb50e3025ac4bfe1c3236c1d34"><td class="memItemLeft" align="right" valign="top">const ComponentType::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a219aacfb50e3025ac4bfe1c3236c1d34">componentType</a></td></tr>
<tr class="separator:a219aacfb50e3025ac4bfe1c3236c1d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ebe24dfab4cbbfe29da9b0325e6c75" id="r_a70ebe24dfab4cbbfe29da9b0325e6c75"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70ebe24dfab4cbbfe29da9b0325e6c75">children</a></td></tr>
<tr class="separator:a70ebe24dfab4cbbfe29da9b0325e6c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe38040d7626abb1b8dd89843fde1797" id="r_abe38040d7626abb1b8dd89843fde1797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe38040d7626abb1b8dd89843fde1797">parent</a> { nullptr }</td></tr>
<tr class="separator:abe38040d7626abb1b8dd89843fde1797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a3e3d97a75d97bd83ebe330d1924b5" id="r_ae3a3e3d97a75d97bd83ebe330d1924b5"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; <a class="el" href="classsys__sage_1_1_relation.html">Relation</a> * &gt; *, RelationType::_num_relation_types &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a3e3d97a75d97bd83ebe330d1924b5">relations</a> = nullptr</td></tr>
<tr class="separator:ae3a3e3d97a75d97bd83ebe330d1924b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic class for all hardware and logical components in sys-sage. </p>
<p>All components inherit from this class, which defines attributes and methods common to all components. This enables a unified interface for tree traversal, querying, and manipulation. Usually, a <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> instance is one of the derived subclasses, but a generic <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> is also possible. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b88f9dcdd64b7621d969642a1e7b4a1" name="a7b88f9dcdd64b7621d969642a1e7b4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b88f9dcdd64b7621d969642a1e7b4a1">&#9670;&#160;</a></span>Component() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sys_sage::Component::Component </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>_name</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;unknown&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> constructor (no automatic insertion in the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree). Usually one of the derived subclasses for different <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Types will be created, not this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_id</td><td>Numeric ID of the component (default 0) </td></tr>
    <tr><td class="paramname">_name</td><td>Name of the component (default "unknown")</td></tr>
  </table>
  </dd>
</dl>
<p>Sets componentType to sys_sage::ComponentType::None. </p>

</div>
</div>
<a id="adc011565236186c83106770e789d454b" name="adc011565236186c83106770e789d454b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc011565236186c83106770e789d454b">&#9670;&#160;</a></span>Component() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sys_sage::Component::Component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>_name</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;unknown&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> constructor with insertion into the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree as the parent's child. Usually one of the derived subclasses for different <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Types will be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Pointer to the parent component </td></tr>
    <tr><td class="paramname">_id</td><td>Numeric ID of the component (default 0) </td></tr>
    <tr><td class="paramname">_name</td><td>Name of the component (default "unknown")</td></tr>
  </table>
  </dd>
</dl>
<p>Sets componentType to sys_sage::ComponentType::None. </p>

</div>
</div>
<a id="a5151f3f53a35acf43c4f0717d88ee68a" name="a5151f3f53a35acf43c4f0717d88ee68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5151f3f53a35acf43c4f0717d88ee68a">&#9670;&#160;</a></span>Component() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sys_sage::Component::Component </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected constructor for derived classes (no automatic insertion in the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_id</td><td>Numeric ID of the component </td></tr>
    <tr><td class="paramname">_name</td><td>Name of the component </td></tr>
    <tr><td class="paramname">_componentType</td><td><a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> type (of type sys_sage::ComponentType::type) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4470d24dbac731175ce1f1cf51ed4d94" name="a4470d24dbac731175ce1f1cf51ed4d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4470d24dbac731175ce1f1cf51ed4d94">&#9670;&#160;</a></span>Component() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sys_sage::Component::Component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected constructor for derived classes with insertion into the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Pointer to the parent component </td></tr>
    <tr><td class="paramname">_id</td><td>Numeric ID of the component </td></tr>
    <tr><td class="paramname">_name</td><td>Name of the component </td></tr>
    <tr><td class="paramname">_componentType</td><td><a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> type (of type sys_sage::ComponentType::type) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a84fce4641fa6a741668f0ba02fe72e15" name="a84fce4641fa6a741668f0ba02fe72e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fce4641fa6a741668f0ba02fe72e15">&#9670;&#160;</a></span>CheckComponentTreeConsistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::CheckComponentTreeConsistency </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the consistency of the component tree starting from this component. </p>
<p>This function verifies that each child component has this component set as its parent. It logs an error message for each child that has an incorrect parent and increments the error count. The function then recursively checks the consistency of the entire subtree rooted at each child component.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of inconsistencies found in the component tree.</dd></dl>
<p>The function returns the total number of errors found in the component tree, including errors in the direct children and any nested descendants. </p>

</div>
</div>
<a id="a5a3d9b9cf3391c9f23b5228477c9c072" name="a5a3d9b9cf3391c9f23b5228477c9c072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3d9b9cf3391c9f23b5228477c9c072">&#9670;&#160;</a></span>CountAllChildrenByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::CountAllChildrenByType </td>
          <td>(</td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of children matching the requested component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- <a class="el" href="namespace_component_type.html" title="Enumerates all supported component types in sys-sage.">ComponentType</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of children matching the requested component type. </dd></dl>

</div>
</div>
<a id="a2adf18964122974506a626022e510472" name="a2adf18964122974506a626022e510472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adf18964122974506a626022e510472">&#9670;&#160;</a></span>CountAllSubcomponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::CountAllSubcomponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of subcomponents (children, grandchildren, etc.). </p>
<dl class="section return"><dt>Returns</dt><dd>Number of subcomponents </dd></dl>

</div>
</div>
<a id="a0d642e68a8be377dbba51469599e6893" name="a0d642e68a8be377dbba51469599e6893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d642e68a8be377dbba51469599e6893">&#9670;&#160;</a></span>CountAllSubcomponentsByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::CountAllSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of subcomponents (children, their children and so on) matching the requested component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- <a class="el" href="namespace_component_type.html" title="Enumerates all supported component types in sys-sage.">ComponentType</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of subcomponents matching the requested component type. </dd></dl>

</div>
</div>
<a id="a8f18c9b1fab65c52467804d4051e3f01" name="a8f18c9b1fab65c52467804d4051e3f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f18c9b1fab65c52467804d4051e3f01">&#9670;&#160;</a></span>Delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::Delete </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withSubtree</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a component, its children (if withSubtree = true), and all associated Relations. If only the component itself is deleted, its children are inserted into its parent's children list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">withSubtree</td><td>If true, the whole subtree is deleted; otherwise only the component itself. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a1585090f3d99a344e663d36a9eef6e" name="a0a1585090f3d99a344e663d36a9eef6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1585090f3d99a344e663d36a9eef6e">&#9670;&#160;</a></span>DeleteAllDataPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::DeleteAllDataPaths </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all DataPaths of this component. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd>Use void DeleteAllRelations(int32_t relationType = sys_sage::RelationType::Any) instead. </dd></dl>

</div>
</div>
<a id="aa28f751289bc49b18cb716c625e8e944" name="aa28f751289bc49b18cb716c625e8e944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28f751289bc49b18cb716c625e8e944">&#9670;&#160;</a></span>DeleteAllRelations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::DeleteAllRelations </td>
          <td>(</td>
          <td class="paramtype">RelationType::type</td>          <td class="paramname"><span class="paramname"><em>relationType</em><span class="paramdefsep"> = </span><span class="paramdefval">RelationType::Any</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all relations of this component (optionally filtered by type). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relationType</td><td><a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">Relation</a> type to delete (default: Any) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1728d7de6b379d7e32c0d302a468ef9" name="ad1728d7de6b379d7e32c0d302a468ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1728d7de6b379d7e32c0d302a468ef9">&#9670;&#160;</a></span>DeleteDataPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::DeleteDataPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_data_path.html">DataPath</a> *</td>          <td class="paramname"><span class="paramname"><em>dp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes and deallocates the <a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a> pointer from the list of outgoing/incoming DataPaths. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated</a></b></dt><dd>Use void <a class="el" href="#a56b4efc89591b330695021079b029a19" title="Deletes a Relation from this component as well as the Relation itself.">DeleteRelation(Relation * r)</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dp</td><td><a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a> to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b4efc89591b330695021079b029a19" name="a56b4efc89591b330695021079b029a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b4efc89591b330695021079b029a19">&#9670;&#160;</a></span>DeleteRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::DeleteRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_relation.html">Relation</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a <a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">Relation</a> from this component as well as the <a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">Relation</a> itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Pointer to the relation to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Relation/DataPath/QuantumGate <a class="el" href="#a8f18c9b1fab65c52467804d4051e3f01" title="Deletes a component, its children (if withSubtree = true), and all associated Relations....">Delete()</a> </dd></dl>

</div>
</div>
<a id="ae61b2467f1b0207a50ce2e5dce7b9a05" name="ae61b2467f1b0207a50ce2e5dce7b9a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61b2467f1b0207a50ce2e5dce7b9a05">&#9670;&#160;</a></span>DeleteSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::DeleteSubtree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the whole subtree (all the children) of the component. </p>

</div>
</div>
<a id="a18783dfe98dc27be1a556cab90d99b87" name="a18783dfe98dc27be1a556cab90d99b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18783dfe98dc27be1a556cab90d99b87">&#9670;&#160;</a></span>GetAllChildrenByType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; sys_sage::Component::GetAllChildrenByType </td>
          <td>(</td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for all children matching the given component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>Required type of components </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of all matching children </dd></dl>

</div>
</div>
<a id="a618d16b87006b900f873456ee179c0e4" name="a618d16b87006b900f873456ee179c0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618d16b87006b900f873456ee179c0e4">&#9670;&#160;</a></span>GetAllChildrenByType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::GetAllChildrenByType </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>_outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for all the children matching the given component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- Required type of components </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, nothing will be pushed into the vector.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7937e5e8ef77443b88dae67a42eb80b" name="aa7937e5e8ef77443b88dae67a42eb80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7937e5e8ef77443b88dae67a42eb80b">&#9670;&#160;</a></span>GetAllDataPaths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsys__sage_1_1_data_path.html">sys_sage::DataPath</a> * &gt; sys_sage::Component::GetAllDataPaths </td>
          <td>(</td>
          <td class="paramtype">DataPathType::type</td>          <td class="paramname"><span class="paramname"><em>dp_type</em><span class="paramdefsep"> = </span><span class="paramdefval">DataPathType::Any</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataPathDirection::type</td>          <td class="paramname"><span class="paramname"><em>direction</em><span class="paramdefsep"> = </span><span class="paramdefval">DataPathDirection::Any</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves all DataPath* from the list of this component's data paths with matching type and orientation/direction. Results are returned in a std::vector&lt;DataPath*&gt;*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dp_type</td><td><a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a> type to search for (default: Any) </td></tr>
    <tr><td class="paramname">direction</td><td>Orientation (default: Any) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of matching DataPaths </dd></dl>

</div>
</div>
<a id="a03568c03fc078afb105a70263a247dde" name="a03568c03fc078afb105a70263a247dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03568c03fc078afb105a70263a247dde">&#9670;&#160;</a></span>GetAllDataPaths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::GetAllDataPaths </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsys__sage_1_1_data_path.html">DataPath</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outDpArr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataPathType::type</td>          <td class="paramname"><span class="paramname"><em>dp_type</em><span class="paramdefsep"> = </span><span class="paramdefval">DataPathType::Any</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataPathDirection::type</td>          <td class="paramname"><span class="paramname"><em>direction</em><span class="paramdefsep"> = </span><span class="paramdefval">DataPathDirection::Any</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves all DataPath* from the list of this component's data paths with matching type and orientation. Results are returned in std::vector&lt;DataPath*&gt;* outDpArr, where first the matching data paths in dp_outgoing are pushed back, then the ones in dp_incoming. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outDpArr</td><td>- output parameter (vector with results) An input is pointer to a std::vector&lt;DataPath *&gt;, in which the data paths will be pushed. It must be allocated before the call (but does not have to be empty). The method pushes back the found data paths &ndash; i.e. the data paths(pointers) can be found in this array after the method returns. (If no found, the vector is not changed.) </td></tr>
    <tr><td class="paramname">dp_type</td><td><a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a> type to search for (default: Any) </td></tr>
    <tr><td class="paramname">direction</td><td>Orientation/direction of a <a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a> (default: Any) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6e60583790bdc02d85b54333c7a7bfd" name="ac6e60583790bdc02d85b54333c7a7bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e60583790bdc02d85b54333c7a7bfd">&#9670;&#160;</a></span>GetAllRelationsBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsys__sage_1_1_relation.html">sys_sage::Relation</a> * &gt; sys_sage::Component::GetAllRelationsBy </td>
          <td>(</td>
          <td class="paramtype">RelationType::type</td>          <td class="paramname"><span class="paramname"><em>relationType</em><span class="paramdefsep"> = </span><span class="paramdefval">RelationType::Any</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thisComponentPosition</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a newly-constructed vector of all relations of a given type and position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relationType</td><td>Type of relation (default: Any) </td></tr>
    <tr><td class="paramname">thisComponentPosition</td><td>Position of this component in the relation (default: -1 = do NOT care about position) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of matching relations (copy, not reference) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>getRelations(RelationType::type relationType) const as an alternative that returns a reference to the internal structure, i.e. has less overhead. </dd></dl>

</div>
</div>
<a id="a96b43f386c4534fb4c15ac60fe465359" name="a96b43f386c4534fb4c15ac60fe465359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b43f386c4534fb4c15ac60fe465359">&#9670;&#160;</a></span>GetAllSubcomponentsByType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; sys_sage::Component::GetAllSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for all the subcomponents (children, their children and so on) matching the given component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- Required type of components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of all the subcomponents matching the _componentType. </dd></dl>

</div>
</div>
<a id="a3a428eeef0ff87ab5cdd1ff4bc4cc128" name="a3a428eeef0ff87ab5cdd1ff4bc4cc128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a428eeef0ff87ab5cdd1ff4bc4cc128">&#9670;&#160;</a></span>GetAllSubcomponentsByType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::GetAllSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for all the subcomponents (children, their children and so on) matching the given component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- Required type of components </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, nothing will be pushed into the vector.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d09a836476b9076fb70cd52ee055059" name="a0d09a836476b9076fb70cd52ee055059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d09a836476b9076fb70cd52ee055059">&#9670;&#160;</a></span>GetAncestorByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * sys_sage::Component::GetAncestorByType </td>
          <td>(</td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves up the tree until a parent of the given type is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>Desired component type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the ancestor, or nullptr if not found </dd></dl>

</div>
</div>
<a id="a40cee810e3f609347034bd398d87ca29" name="a40cee810e3f609347034bd398d87ca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cee810e3f609347034bd398d87ca29">&#9670;&#160;</a></span>GetChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * sys_sage::Component::GetChild </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a Component* to a child with child.id=_id. Identical to GetChildById <br  />
 Should there be more children with the same id, the first match will be retrieved (i.e. the one with lower index in the children array.) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a93f5d098e80c3c90f9c2869838f1034b" title="Retrieve a Component* to a child with child.id=_id. Should there be more children with the same id,...">GetChildById</a> </dd></dl>

</div>
</div>
<a id="a78b6fa0489f5c3b97ed636a4ec285dfe" name="a78b6fa0489f5c3b97ed636a4ec285dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b6fa0489f5c3b97ed636a4ec285dfe">&#9670;&#160;</a></span>GetChildByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * sys_sage::Component::GetChildByType </td>
          <td>(</td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a Component* to a child matching the given component type. Should there be more children with the same type, the first match will be retrieved (i.e. the one with lower index in the children array.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td><a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> type to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first matching child, or nullptr if not found </dd></dl>

</div>
</div>
<a id="a102573e48304e787ee8920fc419f8255" name="a102573e48304e787ee8920fc419f8255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102573e48304e787ee8920fc419f8255">&#9670;&#160;</a></span>GetChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * &gt; &amp; sys_sage::Component::GetChildren </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to std::vector containing all children of the component (empty vector if no children). </p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;Component *&gt; &amp; with children </dd></dl>

</div>
</div>
<a id="ad0be4d6bed7f70dfdd9d522a0c78710d" name="ad0be4d6bed7f70dfdd9d522a0c78710d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0be4d6bed7f70dfdd9d522a0c78710d">&#9670;&#160;</a></span>GetComponentsInSubtree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * &gt; sys_sage::Component::GetComponentsInSubtree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which form the subtree (current node and all the subcomponents) of this. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Component*&gt; with the results. </dd></dl>

</div>
</div>
<a id="acf88f6d2e0bd8f5e1ed151e640c304ad" name="acf88f6d2e0bd8f5e1ed151e640c304ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf88f6d2e0bd8f5e1ed151e640c304ad">&#9670;&#160;</a></span>GetComponentsInSubtree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::GetComponentsInSubtree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which form the subtree (current node and all the subcomponents) of this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, the vector is not changed.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d2e003475f48a9b717c441fb592dd19" name="a3d2e003475f48a9b717c441fb592dd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2e003475f48a9b717c441fb592dd19">&#9670;&#160;</a></span>GetComponentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sys_sage::ComponentType::type sys_sage::Component::GetComponentType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns component type of the component. The component type denotes which class the instance is (often stored as Component*, even though they are a member of one of the child classes). </p>
<dl class="section return"><dt>Returns</dt><dd>componentType (of type sys_sage::ComponentType::type) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a219aacfb50e3025ac4bfe1c3236c1d34">componentType</a> </dd></dl>

</div>
</div>
<a id="a606533d6eb18de70c51d8ca6cc0c3cd8" name="a606533d6eb18de70c51d8ca6cc0c3cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606533d6eb18de70c51d8ca6cc0c3cd8">&#9670;&#160;</a></span>GetComponentTypeStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sys_sage::Component::GetComponentTypeStr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns component type as a human-readable string, as defined in ComponentType::names. </p>
<dl class="section return"><dt>Returns</dt><dd>String representation of the component type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a219aacfb50e3025ac4bfe1c3236c1d34">componentType</a> </dd></dl>

</div>
</div>
<a id="a45d8add279b57e243f8dc4e12f8a2646" name="a45d8add279b57e243f8dc4e12f8a2646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d8add279b57e243f8dc4e12f8a2646">&#9670;&#160;</a></span>GetDataPathByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsys__sage_1_1_data_path.html">sys_sage::DataPath</a> * sys_sage::Component::GetDataPathByType </td>
          <td>(</td>
          <td class="paramtype">DataPathType::type</td>          <td class="paramname"><span class="paramname"><em>dp_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataPathDirection::type</td>          <td class="paramname"><span class="paramname"><em>direction</em><span class="paramdefsep"> = </span><span class="paramdefval">DataPathDirection::Any</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a DataPath* from the list of this component's data paths with matching <a class="el" href="namespace_data_path_type.html" title="Enumerates types of DataPaths (logical, physical, etc.).">DataPathType</a> and <a class="el" href="namespace_data_path_direction.html" title="Enumerates directionality for DataPaths.">DataPathDirection</a>. The first match is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dp_type</td><td><a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a> type to search for </td></tr>
    <tr><td class="paramname">direction</td><td>Orientation (default: Any) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the found <a class="el" href="classsys__sage_1_1_data_path.html" title="Represents a data path (arbitrary relation or data movement) between two Components in the topology.">DataPath</a>, or nullptr if not found </dd></dl>

</div>
</div>
<a id="aff2f25a7b4f370bcb071f4ad9cc689a5" name="aff2f25a7b4f370bcb071f4ad9cc689a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2f25a7b4f370bcb071f4ad9cc689a5">&#9670;&#160;</a></span>GetDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::GetDepth </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>refresh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the depth (level) of a component in the topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refresh</td><td>If true, recalculate the position (depth) of the component in the tree; if false, return the already stored value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Depth (level) of the component in the topology </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a766867133d2273ceb287637583138101">depth</a> </dd></dl>

</div>
</div>
<a id="afe5dd63767b1099de90f4f4f58024202" name="afe5dd63767b1099de90f4f4f58024202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5dd63767b1099de90f4f4f58024202">&#9670;&#160;</a></span>GetId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::GetId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns id of the component. </p>
<dl class="section return"><dt>Returns</dt><dd>id </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a754d00f6d7541f59961815e4119ac7fe">id</a> </dd></dl>

</div>
</div>
<a id="a571e19ef662f6854e511f514251198e9" name="a571e19ef662f6854e511f514251198e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571e19ef662f6854e511f514251198e9">&#9670;&#160;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; sys_sage::Component::GetName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns name of the component. </p>
<dl class="section return"><dt>Returns</dt><dd>Name </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7f8228f2c1fc33fd4507cb4ff1cd91fc">name</a> </dd></dl>

</div>
</div>
<a id="a83ad84ea937833249a7dc5f90c20dae1" name="a83ad84ea937833249a7dc5f90c20dae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ad84ea937833249a7dc5f90c20dae1">&#9670;&#160;</a></span>GetNthAncestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * sys_sage::Component::GetNthAncestor </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves Nth ancestor, which resides N levels above. E.g. if n=1, the parent is retrieved; if n=2, the grandparent is retrieved and so on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- how many levels above the tree should be looked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestor residing N levels above. </dd></dl>

</div>
</div>
<a id="aaa7c5a5bc47f5d0e0154320a61c9d4a5" name="aaa7c5a5bc47f5d0e0154320a61c9d4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7c5a5bc47f5d0e0154320a61c9d4a5">&#9670;&#160;</a></span>GetNthDescendents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * &gt; sys_sage::Component::GetNthDescendents </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside 'depth' levels deeper. The tree is traversed in order as the children are stored in the std::vector. E.g. if depth=1, only children of the current are retrieved; if depth=2, only children of the children are retrieved.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- how many levels down the tree should be looked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Component*&gt; with the results. </dd></dl>

</div>
</div>
<a id="a55c18e4f1393f04444cada28b3845499" name="a55c18e4f1393f04444cada28b3845499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c18e4f1393f04444cada28b3845499">&#9670;&#160;</a></span>GetNthDescendents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::GetNthDescendents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside 'depth' levels deeper. The tree is traversed in order as the children are stored in std::vector children. E.g. if depth=1, only children of the current are retrieved; if depth=2, only children of the children are retrieved.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- how many levels down the tree should be looked </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, nothing will be pushed into the vector.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a912206e825439c92a7f19b9b58c06dc7" name="a912206e825439c92a7f19b9b58c06dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912206e825439c92a7f19b9b58c06dc7">&#9670;&#160;</a></span>GetRelations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classsys__sage_1_1_relation.html">sys_sage::Relation</a> * &gt; &amp; sys_sage::Component::GetRelations </td>
          <td>(</td>
          <td class="paramtype">RelationType::type</td>          <td class="paramname"><span class="paramname"><em>relationType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a (const) reference to the internal vector of relations for a given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relationType</td><td>Type of relation (see <a class="el" href="namespace_relation_type.html" title="Enumerates all supported relation types in sys-sage.">RelationType</a> for available types). Only use specific <a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">Relation</a> Types, not RelationType::Any (you will get an empty vector). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;Relation*&gt;&amp; (reference to internal structure) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vector is const so that the Relations of a <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> cannot be manipulated this way. Use new Relation()/DeleteRelation() to modify the list of Relations, or access the Relations' API directly. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>FindAllRelationsBy(RelationType::type relationType = RelationType::Any, int thisComponentPosition = -1) as an alternative offering more flexibility at the price of increased overhead through generating a new output vector. </dd></dl>

</div>
</div>
<a id="adbecea49599fba84e09700818acf3476" name="adbecea49599fba84e09700818acf3476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbecea49599fba84e09700818acf3476">&#9670;&#160;</a></span>GetSubcomponentById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * sys_sage::Component::GetSubcomponentById </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the subtree to find a component with a matching id and componentType, i.e. looks for a certain component with a matching ID. The search is a DFS. The search starts with the calling component. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns first occurence that matches these criteria. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_id</td><td>- the id to look for </td></tr>
    <tr><td class="paramname">_componentType</td><td>- the component type where to look for the id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> * matching the criteria. Returns the first match. NULL if no match found </dd></dl>

</div>
</div>
<a id="ad8b2d9ae8b2188938995a208f00834c4" name="ad8b2d9ae8b2188938995a208f00834c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b2d9ae8b2188938995a208f00834c4">&#9670;&#160;</a></span>GetSubcomponentsByType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">sys_sage::Component</a> * &gt; sys_sage::Component::GetSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside in the subtree and have a matching type. The tree is traversed DFS in order as the children are stored in the std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentType</td><td>- componentType </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Component*&gt; with the results. </dd></dl>

</div>
</div>
<a id="a2581cf51ba958d2319f7c2c00cd4cac5" name="a2581cf51ba958d2319f7c2c00cd4cac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2581cf51ba958d2319f7c2c00cd4cac5">&#9670;&#160;</a></span>GetSubcomponentsByType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::GetSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentType::type</td>          <td class="paramname"><span class="paramname"><em>componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a std::vector of <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> pointers, which reside in the subtree and have a matching type. The tree is traversed DFS in order as the children are stored in each std::vector children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentType</td><td>- componentType </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, the vector is not changed.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95564c43b5f7ffb6255bc85b95e9e1b0" name="a95564c43b5f7ffb6255bc85b95e9e1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95564c43b5f7ffb6255bc85b95e9e1b0">&#9670;&#160;</a></span>GetSubtreeDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::GetSubtreeDepth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves maximal distance to a leaf (i.e. the depth of the subtree). 0=leaf, 1=children are leaves, 2=at most children's children are leaves ..... </p>
<dl class="section return"><dt>Returns</dt><dd>maximal distance to a leaf </dd></dl>

</div>
</div>
<a id="acd63a616e51fb087826b818e43f4c0e1" name="acd63a616e51fb087826b818e43f4c0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63a616e51fb087826b818e43f4c0e1">&#9670;&#160;</a></span>GetTopologySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::GetTopologySize </td>
          <td>(</td>
          <td class="paramtype">unsigned *</td>          <td class="paramname"><span class="paramname"><em>out_component_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *</td>          <td class="paramname"><span class="paramname"><em>out_dataPathSize</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates approximate memory footprint of the subtree of this element (including the relevant Relations). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_component_size</td><td>output parameter (contains the footprint of the component tree elements); an already allocated unsigned * is the input, the value is expected to be 0 (the result is accumulated here) </td></tr>
    <tr><td class="paramname">out_dataPathSize</td><td>output parameter (contains the footprint of the data-path graph elements); an already allocated unsigned * is the input, the value is expected to be 0 (the result is accumulated here) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total size in bytes </dd></dl>

</div>
</div>
<a id="aeb0b71ad4e6174cd97e47eb778c51f94" name="aeb0b71ad4e6174cd97e47eb778c51f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0b71ad4e6174cd97e47eb778c51f94">&#9670;&#160;</a></span>InsertBetweenParentAndChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::InsertBetweenParentAndChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alreadyParentsChild</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts this component between a parent and one of its children. The parent component remains the parent, this <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> becomes a new child of the parent, and the specified child becomes this component's child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent component to which this component will be inserted as a child. </td></tr>
    <tr><td class="paramname">child</td><td>The child component that will become the child of this component and will remain a descendant of the original parent. </td></tr>
    <tr><td class="paramname">alreadyParentsChild</td><td>A boolean flag indicating whether this component is already a child of the parent. <br  />
 If true, the function assumes that this component is already present as a child of the parent and only needs to reassign the specified child. <br  />
 If false, the function will add this component as a new child of the parent after reassigning the specified child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; 1 if the child and parent are not child and parent in the component tree; 2 if the component tree is corrupt (parent is a parent of child but child is not in the parent's children list); 3 if the component tree is corrupt (parent is not a parent of child but child is in the parent's children list). </dd></dl>

</div>
</div>
<a id="a69d49c3a64ecc683d09402a6430ae766" name="a69d49c3a64ecc683d09402a6430ae766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d49c3a64ecc683d09402a6430ae766">&#9670;&#160;</a></span>InsertBetweenParentAndChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::InsertBetweenParentAndChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsys__sage_1_1_component.html">Component</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>children</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alreadyParentsChild</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts this component between a parent and a (subset of) its children. The parent component remains parent, this <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> becomes a new child, and the children become parent's grandchildren. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent component to which this component will be inserted as a child. </td></tr>
    <tr><td class="paramname">children</td><td>A vector of child components that will become the children of this component and the grandchildren of the original parent. </td></tr>
    <tr><td class="paramname">alreadyParentsChild</td><td>A boolean flag indicating whether this component is already a child of the parent. <br  />
 If true, the function assumes that this component is already present as a child of the parent and only needs to reassign the specified children. <br  />
 If false, the function will add this component as a new child of the parent after reassigning the specified children. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success <br  />
 1 on incompatible parent-children components (one or more children are not parent's children); <br  />
 2 on corrupt component tree (parent is a parent of child but child is NOT in children list of parent); <br  />
 3 on corrupt component tree (parent is NOT a parent of child but child is in children list of parent) </dd></dl>

</div>
</div>
<a id="a7b5934196560dc1ff0fcbb349d45bb86" name="a7b5934196560dc1ff0fcbb349d45bb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5934196560dc1ff0fcbb349d45bb86">&#9670;&#160;</a></span>InsertChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::InsertChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a child component to this component (in the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree). The child pointer will be inserted at the end of the children vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>Pointer to a <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> (or any class instance that inherits from <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a102573e48304e787ee8920fc419f8255" title="Returns a const reference to std::vector containing all children of the component (empty vector if no...">GetChildren()</a> </dd>
<dd>
GetChild(int _id) </dd></dl>

</div>
</div>
<a id="a78d200089dabc30e3045c4711928a0e7" name="a78d200089dabc30e3045c4711928a0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d200089dabc30e3045c4711928a0e7">&#9670;&#160;</a></span>PrintAllDataPathsInSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::PrintAllDataPathsInSubtree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints all DataPaths that go from or to components in the subtree. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>Use PrintAllRelationsInSubtree instead. This function will be removed in the future. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7e254ca10e0fadfcccd32e7d48566b08" title="Prints all Relations in the subtree.">PrintAllRelationsInSubtree</a>( RelationType::type <a class="el" href="namespace_relation_type.html" title="Enumerates all supported relation types in sys-sage.">RelationType</a> = RelationType::Any) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is deprecated and will be removed in the future. Use PrintAllRelationsInSubtree instead. </dd></dl>

</div>
</div>
<a id="a7e254ca10e0fadfcccd32e7d48566b08" name="a7e254ca10e0fadfcccd32e7d48566b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e254ca10e0fadfcccd32e7d48566b08">&#9670;&#160;</a></span>PrintAllRelationsInSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::PrintAllRelationsInSubtree </td>
          <td>(</td>
          <td class="paramtype">RelationType::type</td>          <td class="paramname"><span class="paramname"><em>RelationType</em><span class="paramdefsep"> = </span><span class="paramdefval">RelationType::Any</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints all Relations in the subtree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="namespace_relation_type.html" title="Enumerates all supported relation types in sys-sage.">RelationType</a></td><td>Filter by relation type (default: Any) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0977347b3cff754daa6e3928a60d7409" name="a0977347b3cff754daa6e3928a60d7409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0977347b3cff754daa6e3928a60d7409">&#9670;&#160;</a></span>RemoveChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::RemoveChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the passed component from the list of children, without completely deleting (and deallocating) the child itself. </p>
<p>Removes the passed component from the list of children, without completely deleting (and deallocating) the child itself </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>- child to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>how many elements were deleted (normally, 0 or 1 should be possible) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>Child to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements deleted (normally 0 or 1) </dd></dl>

</div>
</div>
<a id="ac14104ef976caf0fecf60b7f6a747152" name="ac14104ef976caf0fecf60b7f6a747152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14104ef976caf0fecf60b7f6a747152">&#9670;&#160;</a></span>SetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::SetName </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets name of the component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>Name of the component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7f8228f2c1fc33fd4507cb4ff1cd91fc">name</a> </dd></dl>

</div>
</div>
<a id="a80c3ddae6f20f000f711d4354cf5f0e2" name="a80c3ddae6f20f000f711d4354cf5f0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c3ddae6f20f000f711d4354cf5f0e2">&#9670;&#160;</a></span>SetParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_sage::Component::SetParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsys__sage_1_1_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a parent to the component. This is usually used when inserting a component in the tree (by calling InsertChild on the parent, and calling SetParent on the child). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Pointer to a <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> (or any class instance that inherits from <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7b5934196560dc1ff0fcbb349d45bb86" title="Inserts a child component to this component (in the Component Tree). The child pointer will be insert...">InsertChild()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0f6118c4deef5da3aa3e624322a5d604" name="a0f6118c4deef5da3aa3e624322a5d604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6118c4deef5da3aa3e624322a5d604">&#9670;&#160;</a></span>attrib</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, void*&gt; sys_sage::Component::attrib</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A map for storing arbitrary pieces of information or data.</p><ul>
<li>The <code>key</code> denotes the name of the attribute.</li>
<li>The <code>value</code> points to the data, stored as a <code>void*</code>.</li>
</ul>
<p>This data structure is designed to store a wide variety of data types by utilizing pointers to void. Due to its flexibility, it is essential to manage the types and memory allocation/deallocation carefully to avoid issues such as memory leaks or undefined behavior.</p>
<p>Usage:</p>
<ol type="1">
<li>Adding a new key-value pair:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span>* value = <span class="keyword">new</span> int(42); <span class="comment">// Dynamically allocate memory for the value</span></div>
<div class="line"><a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>[key] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(value); <span class="comment">// Store the value in the map</span></div>
<div class="ttc" id="aclasssys__sage_1_1_component_html_a0f6118c4deef5da3aa3e624322a5d604"><div class="ttname"><a href="#a0f6118c4deef5da3aa3e624322a5d604">sys_sage::Component::attrib</a></div><div class="ttdeci">std::map&lt; std::string, void * &gt; attrib</div><div class="ttdef"><b>Definition</b> Component.hpp:571</div></div>
</div><!-- fragment --><ol type="1">
<li>Retrieving data from an existing key:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.find(key) != <a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.end()) {</div>
<div class="line">    <span class="keywordtype">int</span>* retrievedValue = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>[key]);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value: &quot;</span> &lt;&lt; *retrievedValue &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Key not found.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Checking for the existence of a key:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.find(key) != <a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.end()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Key exists.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Key does not exist.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Removing a key-value pair and freeing memory:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.find(key) != <a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.end()) {</div>
<div class="line">    <span class="keywordtype">int</span>* value = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>[key]);</div>
<div class="line">    <span class="keyword">delete</span> value; <span class="comment">// Free the dynamically allocated memory</span></div>
<div class="line">    <a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.erase(key); <span class="comment">// Remove the key-value pair from the map</span></div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Updating the value for an existing key:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.find(key) != <a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>.end()) {</div>
<div class="line">    <span class="keywordtype">int</span>* oldValue = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>[key]);</div>
<div class="line">    <span class="keyword">delete</span> oldValue; <span class="comment">// Free the old value</span></div>
<div class="line">    <span class="keywordtype">int</span>* newValue = <span class="keyword">new</span> int(100); <span class="comment">// Allocate new value</span></div>
<div class="line">    <a class="code hl_variable" href="#a0f6118c4deef5da3aa3e624322a5d604">attrib</a>[key] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(newValue); <span class="comment">// Update the map</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note:</p><ul>
<li>Proper memory management is crucial when using <code>void*</code> pointers. Always ensure that dynamically allocated memory is freed when no longer needed.</li>
<li>Type safety is not enforced, so it is important to cast pointers to the correct type when retrieving values from the map. </li>
</ul>

</div>
</div>
<a id="a70ebe24dfab4cbbfe29da9b0325e6c75" name="a70ebe24dfab4cbbfe29da9b0325e6c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ebe24dfab4cbbfe29da9b0325e6c75">&#9670;&#160;</a></span>children</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsys__sage_1_1_component.html">Component</a>*&gt; sys_sage::Component::children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the list (std::vector) of pointers to children of the component in the component tree. </p>

</div>
</div>
<a id="a219aacfb50e3025ac4bfe1c3236c1d34" name="a219aacfb50e3025ac4bfe1c3236c1d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219aacfb50e3025ac4bfe1c3236c1d34">&#9670;&#160;</a></span>componentType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ComponentType::type sys_sage::Component::componentType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> type of the component. The component type denotes of which class the instance is (often the components are stored as Component*, even though they are a member of one of the child classes) <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> type is constant, set by constructor, readonly. It can be of types as listed in ComponentType::type (which is user-extensible). </p>

</div>
</div>
<a id="a06d4d19be7e780cf2e9a4a88fcd4b5b0" name="a06d4d19be7e780cf2e9a4a88fcd4b5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d4d19be7e780cf2e9a4a88fcd4b5b0">&#9670;&#160;</a></span>count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::count {-1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be used to represent multiple Components with the same properties. By default, it represents only 1 component, and is set to -1. </p>

</div>
</div>
<a id="a766867133d2273ceb287637583138101" name="a766867133d2273ceb287637583138101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766867133d2273ceb287637583138101">&#9670;&#160;</a></span>depth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Depth (level) of the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> in the <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a> Tree </p>

</div>
</div>
<a id="a754d00f6d7541f59961815e4119ac7fe" name="a754d00f6d7541f59961815e4119ac7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754d00f6d7541f59961815e4119ac7fe">&#9670;&#160;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sys_sage::Component::id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numeric ID of the component. There is no requirement for uniqueness of the ID, however it is advised to have unique IDs at least in the realm of parent's children (siblings). Some tree search functions, which take the id as a search parameter search for first match, so the user is responsible to manage uniqueness in the realm of the search subtree (or should be aware of the consequences of not doing so). <a class="el" href="classsys__sage_1_1_component.html" title="Generic class for all hardware and logical components in sys-sage.">Component</a>'s ID is set by the constructor, and is retrieved via int <a class="el" href="#afe5dd63767b1099de90f4f4f58024202" title="Returns id of the component.">GetId()</a>; </p>

</div>
</div>
<a id="a7f8228f2c1fc33fd4507cb4ff1cd91fc" name="a7f8228f2c1fc33fd4507cb4ff1cd91fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8228f2c1fc33fd4507cb4ff1cd91fc">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sys_sage::Component::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Name of the component (as a std::string). </p>

</div>
</div>
<a id="abe38040d7626abb1b8dd89843fde1797" name="abe38040d7626abb1b8dd89843fde1797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe38040d7626abb1b8dd89843fde1797">&#9670;&#160;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsys__sage_1_1_component.html">Component</a>* sys_sage::Component::parent { nullptr }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains pointer to the parent component in the component tree. If this component is the root, parent will be nullptr. </p>

</div>
</div>
<a id="ae3a3e3d97a75d97bd83ebe330d1924b5" name="ae3a3e3d97a75d97bd83ebe330d1924b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a3e3d97a75d97bd83ebe330d1924b5">&#9670;&#160;</a></span>relations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::vector&lt;<a class="el" href="classsys__sage_1_1_relation.html">Relation</a>*&gt;*, RelationType::_num_relation_types&gt;* sys_sage::Component::relations = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains a list (std::array) of different <a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">Relation</a> types. Initially nullptr, it is allocated on the first call to AddRelation() or new Relation(). The array size is RelationType::_num_relation_types, which is defined in <a class="el" href="namespace_relation_type.html" title="Enumerates all supported relation types in sys-sage.">RelationType</a>. Each element of the array is a pointer to a std::vector&lt;Relation*&gt; that contains all Relations of that type. (also lazy-allocated) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/stepan/phd/repos/caps_sys-sage/src/<a class="el" href="_component_8hpp_source.html">Component.hpp</a></li>
<li>/Users/stepan/phd/repos/caps_sys-sage/src/<b>Component.cpp</b></li>
<li>/Users/stepan/phd/repos/caps_sys-sage/src/<b>xml_dump.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
