<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sys-sage: Component Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sys-sage
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_component-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Component Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_component_8hpp_source.html">Component.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Component:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_component.png" usemap="#Component_map" alt=""/>
  <map id="Component_map" name="Component_map">
<area href="class_cache.html" alt="Cache" shape="rect" coords="87,56,164,80"/>
<area href="class_chip.html" alt="Chip" shape="rect" coords="87,112,164,136"/>
<area href="class_core.html" alt="Core" shape="rect" coords="87,168,164,192"/>
<area href="class_memory.html" alt="Memory" shape="rect" coords="87,224,164,248"/>
<area href="class_node.html" alt="Node" shape="rect" coords="87,280,164,304"/>
<area href="class_storage.html" alt="Storage" shape="rect" coords="87,336,164,360"/>
<area href="class_subdivision.html" alt="Subdivision" shape="rect" coords="87,392,164,416"/>
<area href="class_thread.html" alt="Thread" shape="rect" coords="87,448,164,472"/>
<area href="class_topology.html" alt="Topology" shape="rect" coords="87,504,164,528"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9088f15db4d5d9c85faa63b00a7d2600" id="r_a9088f15db4d5d9c85faa63b00a7d2600"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9088f15db4d5d9c85faa63b00a7d2600">Component</a> (int _id=0, string _name=&quot;unknown&quot;, int _componentType=SYS_SAGE_COMPONENT_NONE)</td></tr>
<tr class="separator:a9088f15db4d5d9c85faa63b00a7d2600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f99f69b877a0aa483d663a84c0919a" id="r_ac8f99f69b877a0aa483d663a84c0919a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8f99f69b877a0aa483d663a84c0919a">Component</a> (<a class="el" href="class_component.html">Component</a> *<a class="el" href="#add189dc18ca4dd121d7dede5a0dbeab8">parent</a>, int _id=0, string _name=&quot;unknown&quot;, int _componentType=SYS_SAGE_COMPONENT_NONE)</td></tr>
<tr class="separator:ac8f99f69b877a0aa483d663a84c0919a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8506f89d8714c3fe2a3e435b97b5544f" id="r_a8506f89d8714c3fe2a3e435b97b5544f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8506f89d8714c3fe2a3e435b97b5544f">InsertChild</a> (<a class="el" href="class_component.html">Component</a> *child)</td></tr>
<tr class="separator:a8506f89d8714c3fe2a3e435b97b5544f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5a4c2ebc326905c06556780411bf8b" id="r_aef5a4c2ebc326905c06556780411bf8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef5a4c2ebc326905c06556780411bf8b">InsertBetweenParentAndChild</a> (<a class="el" href="class_component.html">Component</a> *<a class="el" href="#add189dc18ca4dd121d7dede5a0dbeab8">parent</a>, <a class="el" href="class_component.html">Component</a> *child, bool alreadyParentsChild)</td></tr>
<tr class="separator:aef5a4c2ebc326905c06556780411bf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0a58bc196e2a0d578fe2d7626e709a" id="r_abb0a58bc196e2a0d578fe2d7626e709a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb0a58bc196e2a0d578fe2d7626e709a">InsertBetweenParentAndChildren</a> (<a class="el" href="class_component.html">Component</a> *<a class="el" href="#add189dc18ca4dd121d7dede5a0dbeab8">parent</a>, vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; <a class="el" href="#a6c3106b9a8ba60fead5f7bf3430ab00f">children</a>, bool alreadyParentsChild)</td></tr>
<tr class="separator:abb0a58bc196e2a0d578fe2d7626e709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753b5c04b6fc79ff6ebcd89593b701f9" id="r_a753b5c04b6fc79ff6ebcd89593b701f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a753b5c04b6fc79ff6ebcd89593b701f9">RemoveChild</a> (<a class="el" href="class_component.html">Component</a> *child)</td></tr>
<tr class="separator:a753b5c04b6fc79ff6ebcd89593b701f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d4b870ab8f711d030d4a7f1291c42b" id="r_a18d4b870ab8f711d030d4a7f1291c42b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18d4b870ab8f711d030d4a7f1291c42b">SetParent</a> (<a class="el" href="class_component.html">Component</a> *<a class="el" href="#add189dc18ca4dd121d7dede5a0dbeab8">parent</a>)</td></tr>
<tr class="separator:a18d4b870ab8f711d030d4a7f1291c42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cc172d9c737b978ad30f64196e96f9" id="r_ad1cc172d9c737b978ad30f64196e96f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1cc172d9c737b978ad30f64196e96f9">PrintSubtree</a> ()</td></tr>
<tr class="separator:ad1cc172d9c737b978ad30f64196e96f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7a769dc19d12ece34053a9b5294cc9" id="r_a6b7a769dc19d12ece34053a9b5294cc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7a769dc19d12ece34053a9b5294cc9">PrintAllDataPathsInSubtree</a> ()</td></tr>
<tr class="separator:a6b7a769dc19d12ece34053a9b5294cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9d620ac8795ddec325b7e05707b9ef" id="r_a1a9d620ac8795ddec325b7e05707b9ef"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a9d620ac8795ddec325b7e05707b9ef">GetName</a> ()</td></tr>
<tr class="separator:a1a9d620ac8795ddec325b7e05707b9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed28cdfc91df0bac02b7fd3d8955d082" id="r_aed28cdfc91df0bac02b7fd3d8955d082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed28cdfc91df0bac02b7fd3d8955d082">SetName</a> (string _name)</td></tr>
<tr class="separator:aed28cdfc91df0bac02b7fd3d8955d082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e0d9af5f40df0ccad6be3edde7dad0" id="r_aa8e0d9af5f40df0ccad6be3edde7dad0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8e0d9af5f40df0ccad6be3edde7dad0">GetId</a> ()</td></tr>
<tr class="separator:aa8e0d9af5f40df0ccad6be3edde7dad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad508ec920dee8d5800a3e285659c4dab" id="r_ad508ec920dee8d5800a3e285659c4dab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad508ec920dee8d5800a3e285659c4dab">GetComponentType</a> ()</td></tr>
<tr class="separator:ad508ec920dee8d5800a3e285659c4dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32113dd8489115c7e9a1696a8018e7a6" id="r_a32113dd8489115c7e9a1696a8018e7a6"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32113dd8489115c7e9a1696a8018e7a6">GetComponentTypeStr</a> ()</td></tr>
<tr class="separator:a32113dd8489115c7e9a1696a8018e7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfab074ef1ad7f359f22eafb66b59dc" id="r_adbfab074ef1ad7f359f22eafb66b59dc"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbfab074ef1ad7f359f22eafb66b59dc">GetChildren</a> ()</td></tr>
<tr class="separator:adbfab074ef1ad7f359f22eafb66b59dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877ef6f7e49b6d38019988b07a7ceb20" id="r_a877ef6f7e49b6d38019988b07a7ceb20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a877ef6f7e49b6d38019988b07a7ceb20">GetParent</a> ()</td></tr>
<tr class="separator:a877ef6f7e49b6d38019988b07a7ceb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747cc962324d0b1174bcab97efec34f" id="r_ae747cc962324d0b1174bcab97efec34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae747cc962324d0b1174bcab97efec34f">GetChild</a> (int _id)</td></tr>
<tr class="separator:ae747cc962324d0b1174bcab97efec34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f4d535e0e566294a65b5f427065fcf" id="r_a35f4d535e0e566294a65b5f427065fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35f4d535e0e566294a65b5f427065fcf">GetChildById</a> (int _id)</td></tr>
<tr class="separator:a35f4d535e0e566294a65b5f427065fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35ab2b87f61ee9e42e05bfc4fdc4424" id="r_ac35ab2b87f61ee9e42e05bfc4fdc4424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac35ab2b87f61ee9e42e05bfc4fdc4424">GetChildByType</a> (int _componentType)</td></tr>
<tr class="separator:ac35ab2b87f61ee9e42e05bfc4fdc4424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dce463160bf5067e588ebbaecd7e7f" id="r_a10dce463160bf5067e588ebbaecd7e7f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10dce463160bf5067e588ebbaecd7e7f">GetAllChildrenByType</a> (int _componentType)</td></tr>
<tr class="separator:a10dce463160bf5067e588ebbaecd7e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af328a08f9354a4436045b24728e371" id="r_a1af328a08f9354a4436045b24728e371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1af328a08f9354a4436045b24728e371">GetAllChildrenByType</a> (vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *_outArray, int _componentType)</td></tr>
<tr class="separator:a1af328a08f9354a4436045b24728e371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dfa5d4a2453292326fe7e3207706be" id="r_a37dfa5d4a2453292326fe7e3207706be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37dfa5d4a2453292326fe7e3207706be">FindSubcomponentById</a> (int _id, int _componentType)</td></tr>
<tr class="separator:a37dfa5d4a2453292326fe7e3207706be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bba5b614c9a3056e14b462a60cce4b" id="r_a75bba5b614c9a3056e14b462a60cce4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75bba5b614c9a3056e14b462a60cce4b">GetSubcomponentById</a> (int _id, int _componentType)</td></tr>
<tr class="separator:a75bba5b614c9a3056e14b462a60cce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0644d7fc3f8b8fbc751abb772e42f4e1" id="r_a0644d7fc3f8b8fbc751abb772e42f4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0644d7fc3f8b8fbc751abb772e42f4e1">GetAllSubcomponentsByType</a> (vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *outArray, int _componentType)</td></tr>
<tr class="separator:a0644d7fc3f8b8fbc751abb772e42f4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568113b71c046a46bd89a862fbc7151" id="r_ac568113b71c046a46bd89a862fbc7151"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac568113b71c046a46bd89a862fbc7151">GetAllSubcomponentsByType</a> (int _componentType)</td></tr>
<tr class="separator:ac568113b71c046a46bd89a862fbc7151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7f01be2115c093132a4e2d90f98e45" id="r_afc7f01be2115c093132a4e2d90f98e45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc7f01be2115c093132a4e2d90f98e45">CountAllSubcomponents</a> ()</td></tr>
<tr class="separator:afc7f01be2115c093132a4e2d90f98e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92027cb1a15c462e5d4b87a65dcbfd" id="r_aeb92027cb1a15c462e5d4b87a65dcbfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb92027cb1a15c462e5d4b87a65dcbfd">CountAllSubcomponentsByType</a> (int _componentType)</td></tr>
<tr class="separator:aeb92027cb1a15c462e5d4b87a65dcbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae217308565f3fb267a055683ca223f1f" id="r_ae217308565f3fb267a055683ca223f1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae217308565f3fb267a055683ca223f1f">CountAllChildrenByType</a> (int _componentType)</td></tr>
<tr class="separator:ae217308565f3fb267a055683ca223f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbc514537adf03cfc41d81b492f8e17" id="r_a8fbc514537adf03cfc41d81b492f8e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fbc514537adf03cfc41d81b492f8e17">GetAncestorByType</a> (int _componentType)</td></tr>
<tr class="separator:a8fbc514537adf03cfc41d81b492f8e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23ffe1aa55edc8b50e39b0835cdc2cf" id="r_ad23ffe1aa55edc8b50e39b0835cdc2cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad23ffe1aa55edc8b50e39b0835cdc2cf">GetNumThreads</a> ()</td></tr>
<tr class="separator:ad23ffe1aa55edc8b50e39b0835cdc2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132ff3a8d0a98d1d1bb113b9f91aec04" id="r_a132ff3a8d0a98d1d1bb113b9f91aec04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a132ff3a8d0a98d1d1bb113b9f91aec04">GetSubtreeDepth</a> ()</td></tr>
<tr class="separator:a132ff3a8d0a98d1d1bb113b9f91aec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9bf890570d4308a42de352e804b821" id="r_a6a9bf890570d4308a42de352e804b821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a9bf890570d4308a42de352e804b821">GetNthAncestor</a> (int n)</td></tr>
<tr class="separator:a6a9bf890570d4308a42de352e804b821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0caa2be5b0a5a24e142cee7e7d27489" id="r_ab0caa2be5b0a5a24e142cee7e7d27489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0caa2be5b0a5a24e142cee7e7d27489">GetNthDescendents</a> (vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *outArray, int <a class="el" href="#a1f32d0806b8c40635e9d4224ed23dede">depth</a>)</td></tr>
<tr class="separator:ab0caa2be5b0a5a24e142cee7e7d27489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763f9885feedbb76ce1c2a8632701f53" id="r_a763f9885feedbb76ce1c2a8632701f53"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a763f9885feedbb76ce1c2a8632701f53">GetNthDescendents</a> (int <a class="el" href="#a1f32d0806b8c40635e9d4224ed23dede">depth</a>)</td></tr>
<tr class="separator:a763f9885feedbb76ce1c2a8632701f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceb7931c7ff2f553e62368e77430c60" id="r_acceb7931c7ff2f553e62368e77430c60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acceb7931c7ff2f553e62368e77430c60">GetSubcomponentsByType</a> (vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *outArray, int <a class="el" href="#ac6d7a80d187b4ec48f6bf6f084378ac0">componentType</a>)</td></tr>
<tr class="separator:acceb7931c7ff2f553e62368e77430c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae40c45cfcdd838e9c703553a8a291c" id="r_a2ae40c45cfcdd838e9c703553a8a291c"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae40c45cfcdd838e9c703553a8a291c">GetSubcomponentsByType</a> (int _componentType)</td></tr>
<tr class="separator:a2ae40c45cfcdd838e9c703553a8a291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2235be0e4a7798a2b6cdbeeeeae5dd8c" id="r_a2235be0e4a7798a2b6cdbeeeeae5dd8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2235be0e4a7798a2b6cdbeeeeae5dd8c">GetComponentsInSubtree</a> (vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *outArray)</td></tr>
<tr class="separator:a2235be0e4a7798a2b6cdbeeeeae5dd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f43d2943b0495c3ef73b5b4e50c396" id="r_aa4f43d2943b0495c3ef73b5b4e50c396"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4f43d2943b0495c3ef73b5b4e50c396">GetComponentsInSubtree</a> ()</td></tr>
<tr class="separator:aa4f43d2943b0495c3ef73b5b4e50c396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29f5f5a1ee41d9b4d448482dc980a0e" id="r_af29f5f5a1ee41d9b4d448482dc980a0e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af29f5f5a1ee41d9b4d448482dc980a0e">GetDataPaths</a> (int orientation)</td></tr>
<tr class="separator:af29f5f5a1ee41d9b4d448482dc980a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46e74efe39f5226ee26ea2bdcdd9a6e" id="r_ab46e74efe39f5226ee26ea2bdcdd9a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_data_path.html">DataPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab46e74efe39f5226ee26ea2bdcdd9a6e">GetDataPathByType</a> (int dp_type, int orientation)</td></tr>
<tr class="separator:ab46e74efe39f5226ee26ea2bdcdd9a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1bb5037ba0f6a0f808d643ad48d758" id="r_a3d1bb5037ba0f6a0f808d643ad48d758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d1bb5037ba0f6a0f808d643ad48d758">GetAllDataPathsByType</a> (vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt; *outDpArr, int dp_type, int orientation)</td></tr>
<tr class="separator:a3d1bb5037ba0f6a0f808d643ad48d758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a5d0d2f77506ce51384d0082f2d349" id="r_a68a5d0d2f77506ce51384d0082f2d349"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a5d0d2f77506ce51384d0082f2d349">GetAllDataPathsByType</a> (int dp_type, int orientation)</td></tr>
<tr class="separator:a68a5d0d2f77506ce51384d0082f2d349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae253dee212b3c4c2a1dff1ce0897ceae" id="r_ae253dee212b3c4c2a1dff1ce0897ceae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae253dee212b3c4c2a1dff1ce0897ceae">CheckComponentTreeConsistency</a> ()</td></tr>
<tr class="memdesc:ae253dee212b3c4c2a1dff1ce0897ceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the consistency of the component tree starting from this component.  <br /></td></tr>
<tr class="separator:ae253dee212b3c4c2a1dff1ce0897ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be4dace6140a0de5f00d9d5ad189d59" id="r_a2be4dace6140a0de5f00d9d5ad189d59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2be4dace6140a0de5f00d9d5ad189d59">GetTopologySize</a> (unsigned *out_component_size, unsigned *out_dataPathSize)</td></tr>
<tr class="separator:a2be4dace6140a0de5f00d9d5ad189d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cededdc084c20d3f83e5d925a2c0c1c" id="r_a5cededdc084c20d3f83e5d925a2c0c1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cededdc084c20d3f83e5d925a2c0c1c">GetDepth</a> (bool refresh)</td></tr>
<tr class="separator:a5cededdc084c20d3f83e5d925a2c0c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3981ff9e6b3f65a2968fedd85fab2905" id="r_a3981ff9e6b3f65a2968fedd85fab2905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3981ff9e6b3f65a2968fedd85fab2905">DeleteDataPath</a> (<a class="el" href="class_data_path.html">DataPath</a> *dp)</td></tr>
<tr class="separator:a3981ff9e6b3f65a2968fedd85fab2905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e8f7352ea4fac3a89285f10db36d34" id="r_aa6e8f7352ea4fac3a89285f10db36d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6e8f7352ea4fac3a89285f10db36d34">DeleteAllDataPaths</a> ()</td></tr>
<tr class="separator:aa6e8f7352ea4fac3a89285f10db36d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82347ac087e660ff48d9173d1add4c37" id="r_a82347ac087e660ff48d9173d1add4c37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82347ac087e660ff48d9173d1add4c37">DeleteSubtree</a> ()</td></tr>
<tr class="separator:a82347ac087e660ff48d9173d1add4c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76450a472dd9b88ac381fe3d17f2923" id="r_ad76450a472dd9b88ac381fe3d17f2923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad76450a472dd9b88ac381fe3d17f2923">Delete</a> (bool withSubtree=true)</td></tr>
<tr class="separator:ad76450a472dd9b88ac381fe3d17f2923"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a17c49e18fd0a5e4ab6000844a5f41645" id="r_a17c49e18fd0a5e4ab6000844a5f41645"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a></td></tr>
<tr class="separator:a17c49e18fd0a5e4ab6000844a5f41645"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7b51904172e22f13a182eb16b7de4aaf" id="r_a7b51904172e22f13a182eb16b7de4aaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b51904172e22f13a182eb16b7de4aaf">id</a></td></tr>
<tr class="separator:a7b51904172e22f13a182eb16b7de4aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f32d0806b8c40635e9d4224ed23dede" id="r_a1f32d0806b8c40635e9d4224ed23dede"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f32d0806b8c40635e9d4224ed23dede">depth</a></td></tr>
<tr class="separator:a1f32d0806b8c40635e9d4224ed23dede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f51bb245c415a384cd29c60f7b25ba2" id="r_a3f51bb245c415a384cd29c60f7b25ba2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f51bb245c415a384cd29c60f7b25ba2">name</a></td></tr>
<tr class="separator:a3f51bb245c415a384cd29c60f7b25ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc084b0920e318e25b82c78a9b6c9a3" id="r_a9cc084b0920e318e25b82c78a9b6c9a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cc084b0920e318e25b82c78a9b6c9a3">count</a> {-1}</td></tr>
<tr class="separator:a9cc084b0920e318e25b82c78a9b6c9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d7a80d187b4ec48f6bf6f084378ac0" id="r_ac6d7a80d187b4ec48f6bf6f084378ac0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6d7a80d187b4ec48f6bf6f084378ac0">componentType</a></td></tr>
<tr class="separator:ac6d7a80d187b4ec48f6bf6f084378ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3106b9a8ba60fead5f7bf3430ab00f" id="r_a6c3106b9a8ba60fead5f7bf3430ab00f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c3106b9a8ba60fead5f7bf3430ab00f">children</a></td></tr>
<tr class="separator:a6c3106b9a8ba60fead5f7bf3430ab00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add189dc18ca4dd121d7dede5a0dbeab8" id="r_add189dc18ca4dd121d7dede5a0dbeab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_component.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add189dc18ca4dd121d7dede5a0dbeab8">parent</a> { nullptr }</td></tr>
<tr class="separator:add189dc18ca4dd121d7dede5a0dbeab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40517588f7b89687289bea681c6bfc79" id="r_a40517588f7b89687289bea681c6bfc79"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40517588f7b89687289bea681c6bfc79">dp_incoming</a></td></tr>
<tr class="separator:a40517588f7b89687289bea681c6bfc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16af6908e826a8a2531f0a0e0d65d533" id="r_a16af6908e826a8a2531f0a0e0d65d533"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16af6908e826a8a2531f0a0e0d65d533">dp_outgoing</a></td></tr>
<tr class="separator:a16af6908e826a8a2531f0a0e0d65d533"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic class <a class="el" href="class_component.html">Component</a> - all components inherit from this class, i.e. this class defines attributes and methods common to all components. <br  />
 Therefore, these can be used universally among all components. Usually, a <a class="el" href="class_component.html">Component</a> instance would be an instance of one of the child classes, but a generic component (instance of class <a class="el" href="class_component.html">Component</a>) is also possible. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9088f15db4d5d9c85faa63b00a7d2600" name="a9088f15db4d5d9c85faa63b00a7d2600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9088f15db4d5d9c85faa63b00a7d2600">&#9670;&#160;</a></span>Component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Component::Component </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string</td>          <td class="paramname"><span class="paramname"><em>_name</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;unknown&quot;</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em><span class="paramdefsep"> = </span><span class="paramdefval">SYS_SAGE_COMPONENT_NONE</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic <a class="el" href="class_component.html">Component</a> constructor (no automatic insertion in the <a class="el" href="class_component.html">Component</a> Tree). Usually one of the derived subclasses for different <a class="el" href="class_component.html">Component</a> Types will be created. Sets: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_id</td><td>= id, default 0 </td></tr>
    <tr><td class="paramname">_name</td><td>= name, default "unknown" </td></tr>
    <tr><td class="paramname">_componentType</td><td>= componentType, default SYS_SAGE_COMPONENT_NONE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8f99f69b877a0aa483d663a84c0919a" name="ac8f99f69b877a0aa483d663a84c0919a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f99f69b877a0aa483d663a84c0919a">&#9670;&#160;</a></span>Component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Component::Component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string</td>          <td class="paramname"><span class="paramname"><em>_name</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;unknown&quot;</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em><span class="paramdefsep"> = </span><span class="paramdefval">SYS_SAGE_COMPONENT_NONE</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic <a class="el" href="class_component.html">Component</a> constructor with insertion into the <a class="el" href="class_component.html">Component</a> Tree as the parent 's child (as long as parent is an existing <a class="el" href="class_component.html">Component</a>). Usually one of the derived subclasses for different <a class="el" href="class_component.html">Component</a> Types will be created. Sets: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>= the parent </td></tr>
    <tr><td class="paramname">_id</td><td>= id, default 0 </td></tr>
    <tr><td class="paramname">_name</td><td>= name, default "unknown" </td></tr>
    <tr><td class="paramname">_componentType</td><td>= componentType, default SYS_SAGE_COMPONENT_NONE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae253dee212b3c4c2a1dff1ce0897ceae" name="ae253dee212b3c4c2a1dff1ce0897ceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae253dee212b3c4c2a1dff1ce0897ceae">&#9670;&#160;</a></span>CheckComponentTreeConsistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::CheckComponentTreeConsistency </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the consistency of the component tree starting from this component. </p>
<p>This function verifies that each child component has this component set as its parent. It logs an error message for each child that has an incorrect parent and increments the error count. The function then recursively checks the consistency of the entire subtree rooted at each child component.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of inconsistencies found in the component tree.</dd></dl>
<p>The function returns the total number of errors found in the component tree, including errors in the direct children and any nested descendants. </p>

</div>
</div>
<a id="ae217308565f3fb267a055683ca223f1f" name="ae217308565f3fb267a055683ca223f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae217308565f3fb267a055683ca223f1f">&#9670;&#160;</a></span>CountAllChildrenByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::CountAllChildrenByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts number of children matching the requested component type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- <a class="el" href="class_component.html">Component</a> type to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of children matching the requested component type. </dd></dl>

</div>
</div>
<a id="afc7f01be2115c093132a4e2d90f98e45" name="afc7f01be2115c093132a4e2d90f98e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7f01be2115c093132a4e2d90f98e45">&#9670;&#160;</a></span>CountAllSubcomponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::CountAllSubcomponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts number of subcomponents (children, their children and so on). </p><dl class="section return"><dt>Returns</dt><dd>Returns number of subcomponents. </dd></dl>

</div>
</div>
<a id="aeb92027cb1a15c462e5d4b87a65dcbfd" name="aeb92027cb1a15c462e5d4b87a65dcbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb92027cb1a15c462e5d4b87a65dcbfd">&#9670;&#160;</a></span>CountAllSubcomponentsByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::CountAllSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts number of subcomponents (children, their children and so on) matching the requested component type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- <a class="el" href="class_component.html">Component</a> type to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of subcomponents matching the requested component type. </dd></dl>

</div>
</div>
<a id="ad76450a472dd9b88ac381fe3d17f2923" name="ad76450a472dd9b88ac381fe3d17f2923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76450a472dd9b88ac381fe3d17f2923">&#9670;&#160;</a></span>Delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::Delete </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withSubtree</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a component, its children (if withSubtree = true) and all the associated data paths. If only the component itself is deleted, its children are inserted into its parent's children list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">withSubtree</td><td>- if true, the whole subtree is deleted, otherwise only the component itself. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6e8f7352ea4fac3a89285f10db36d34" name="aa6e8f7352ea4fac3a89285f10db36d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e8f7352ea4fac3a89285f10db36d34">&#9670;&#160;</a></span>DeleteAllDataPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::DeleteAllDataPaths </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all DataPaths of this component. </p>

</div>
</div>
<a id="a3981ff9e6b3f65a2968fedd85fab2905" name="a3981ff9e6b3f65a2968fedd85fab2905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3981ff9e6b3f65a2968fedd85fab2905">&#9670;&#160;</a></span>DeleteDataPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::DeleteDataPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_data_path.html">DataPath</a> *</td>          <td class="paramname"><span class="paramname"><em>dp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes and de-allocates the <a class="el" href="class_data_path.html">DataPath</a> pointer from the list(std::vector) of outgoing and incoming DataPaths of the Components. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dp</td><td>- <a class="el" href="class_data_path.html">DataPath</a> to Delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82347ac087e660ff48d9173d1add4c37" name="a82347ac087e660ff48d9173d1add4c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82347ac087e660ff48d9173d1add4c37">&#9670;&#160;</a></span>DeleteSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::DeleteSubtree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the whole subtree (all the children) of the component. </p>

</div>
</div>
<a id="a37dfa5d4a2453292326fe7e3207706be" name="a37dfa5d4a2453292326fe7e3207706be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dfa5d4a2453292326fe7e3207706be">&#9670;&#160;</a></span>FindSubcomponentById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::FindSubcomponentById </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OBSOLETE. Use GetSubcomponentById instead. This function will be removed in the future. </p>

</div>
</div>
<a id="a10dce463160bf5067e588ebbaecd7e7f" name="a10dce463160bf5067e588ebbaecd7e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dce463160bf5067e588ebbaecd7e7f">&#9670;&#160;</a></span>GetAllChildrenByType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; Component::GetAllChildrenByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for all the children matching the given component type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- Required type of components </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of all the children matching the _componentType </dd></dl>

</div>
</div>
<a id="a1af328a08f9354a4436045b24728e371" name="a1af328a08f9354a4436045b24728e371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af328a08f9354a4436045b24728e371">&#9670;&#160;</a></span>GetAllChildrenByType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::GetAllChildrenByType </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>_outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for all the children matching the given component type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- Required type of components </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, nothing will be pushed into the vector.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a5d0d2f77506ce51384d0082f2d349" name="a68a5d0d2f77506ce51384d0082f2d349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a5d0d2f77506ce51384d0082f2d349">&#9670;&#160;</a></span>GetAllDataPathsByType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt; Component::GetAllDataPathsByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dp_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves all <a class="el" href="class_data_path.html">DataPath</a> * from the list of this component's data paths with matching type and orientation. Results are returned in a vector&lt;DataPath*&gt;*, where first the matching data paths in dp_outgoing are pushed back, then the ones in dp_incoming. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dp_type</td><td>- <a class="el" href="class_data_path.html">DataPath</a> type (dp_type) to search for. </td></tr>
    <tr><td class="paramname">orientation</td><td>- orientation of the <a class="el" href="class_data_path.html">DataPath</a> (SYS_SAGE_DATAPATH_OUTGOING or SYS_SAGE_DATAPATH_INCOMING or a logical or of these) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;DataPath*&gt; with the results. </dd></dl>

</div>
</div>
<a id="a3d1bb5037ba0f6a0f808d643ad48d758" name="a3d1bb5037ba0f6a0f808d643ad48d758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1bb5037ba0f6a0f808d643ad48d758">&#9670;&#160;</a></span>GetAllDataPathsByType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::GetAllDataPathsByType </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outDpArr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dp_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves all <a class="el" href="class_data_path.html">DataPath</a> * from the list of this component's data paths with matching type and orientation. Results are returned in vector&lt;DataPath*&gt;* outDpArr, where first the matching data paths in dp_outgoing are pushed back, then the ones in dp_incoming. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dp_type</td><td>- <a class="el" href="class_data_path.html">DataPath</a> type (dp_type) to search for. </td></tr>
    <tr><td class="paramname">orientation</td><td>- orientation of the <a class="el" href="class_data_path.html">DataPath</a> (SYS_SAGE_DATAPATH_OUTGOING or SYS_SAGE_DATAPATH_INCOMING or a logical or of these) </td></tr>
    <tr><td class="paramname">outDpArr</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::vector&lt;DataPath *&gt;, in which the data paths will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found data paths &ndash; i.e. the data paths(pointers) can be found in this array after the method returns. (If no found, the vector is not changed.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac568113b71c046a46bd89a862fbc7151" name="ac568113b71c046a46bd89a862fbc7151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac568113b71c046a46bd89a862fbc7151">&#9670;&#160;</a></span>GetAllSubcomponentsByType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; Component::GetAllSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for all the subcomponents (children, their children and so on) matching the given component type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- Required type of components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of all the subcomponents matching the _componentType. </dd></dl>

</div>
</div>
<a id="a0644d7fc3f8b8fbc751abb772e42f4e1" name="a0644d7fc3f8b8fbc751abb772e42f4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0644d7fc3f8b8fbc751abb772e42f4e1">&#9670;&#160;</a></span>GetAllSubcomponentsByType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::GetAllSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for all the subcomponents (children, their children and so on) matching the given component type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- Required type of components </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, nothing will be pushed into the vector.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fbc514537adf03cfc41d81b492f8e17" name="a8fbc514537adf03cfc41d81b492f8e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbc514537adf03cfc41d81b492f8e17">&#9670;&#160;</a></span>GetAncestorByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::GetAncestorByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves up the tree until a parent of given type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_componentType</td><td>- the desired component type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_component.html">Component</a> * matching the criteria. NULL if no match found </dd></dl>

</div>
</div>
<a id="ae747cc962324d0b1174bcab97efec34f" name="ae747cc962324d0b1174bcab97efec34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae747cc962324d0b1174bcab97efec34f">&#9670;&#160;</a></span>GetChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::GetChild </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to GetChildById Retrieve a Component* to a child with child.id=_id. <br  />
 Should there be more children with the same id, the first match will be retrieved (i.e. the one with lower index in the children array.) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a35f4d535e0e566294a65b5f427065fcf">GetChildById</a> </dd></dl>

</div>
</div>
<a id="a35f4d535e0e566294a65b5f427065fcf" name="a35f4d535e0e566294a65b5f427065fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f4d535e0e566294a65b5f427065fcf">&#9670;&#160;</a></span>GetChildById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::GetChildById </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a Component* to a child with child.id=_id. <br  />
 Should there be more children with the same id, the first match will be retrieved (i.e. the one with lower index in the children array.) </p>

</div>
</div>
<a id="ac35ab2b87f61ee9e42e05bfc4fdc4424" name="ac35ab2b87f61ee9e42e05bfc4fdc4424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35ab2b87f61ee9e42e05bfc4fdc4424">&#9670;&#160;</a></span>GetChildByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::GetChildByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a Component* to a child matching the given component type. <br  />
 Should there be more children with the same type, the first match will be retrieved (i.e. the one with lower index in the children array.) </p>

</div>
</div>
<a id="adbfab074ef1ad7f359f22eafb66b59dc" name="adbfab074ef1ad7f359f22eafb66b59dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfab074ef1ad7f359f22eafb66b59dc">&#9670;&#160;</a></span>GetChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; * Component::GetChildren </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to std::vector containing all children of the component (empty vector if no children) . </p><dl class="section return"><dt>Returns</dt><dd>vector&lt;Component *&gt; * with children </dd></dl>

</div>
</div>
<a id="aa4f43d2943b0495c3ef73b5b4e50c396" name="aa4f43d2943b0495c3ef73b5b4e50c396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f43d2943b0495c3ef73b5b4e50c396">&#9670;&#160;</a></span>GetComponentsInSubtree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; Component::GetComponentsInSubtree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a std::vector of <a class="el" href="class_component.html">Component</a> pointers, which form the subtree (current node and all the subcomponents) of this. </p><dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Component*&gt; with the results. </dd></dl>

</div>
</div>
<a id="a2235be0e4a7798a2b6cdbeeeeae5dd8c" name="a2235be0e4a7798a2b6cdbeeeeae5dd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2235be0e4a7798a2b6cdbeeeeae5dd8c">&#9670;&#160;</a></span>GetComponentsInSubtree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::GetComponentsInSubtree </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a std::vector of <a class="el" href="class_component.html">Component</a> pointers, which form the subtree (current node and all the subcomponents) of this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, the vector is not changed.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad508ec920dee8d5800a3e285659c4dab" name="ad508ec920dee8d5800a3e285659c4dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad508ec920dee8d5800a3e285659c4dab">&#9670;&#160;</a></span>GetComponentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::GetComponentType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns component type of the component. The component type denotes of which class the instance is (Often the components are stored as Component*, even though they are a member of one of the child classes) <br  />
 SYS_SAGE_COMPONENT_NONE -&gt; class <a class="el" href="class_component.html">Component</a> <br  />
 SYS_SAGE_COMPONENT_THREAD -&gt; class <a class="el" href="class_thread.html">Thread</a> <br  />
 SYS_SAGE_COMPONENT_CORE -&gt; class <a class="el" href="class_core.html">Core</a> <br  />
 SYS_SAGE_COMPONENT_CACHE -&gt; class <a class="el" href="class_cache.html">Cache</a> <br  />
 SYS_SAGE_COMPONENT_SUBDIVISION -&gt; class <a class="el" href="class_subdivision.html">Subdivision</a> <br  />
 SYS_SAGE_COMPONENT_NUMA -&gt; class <a class="el" href="class_numa.html">Numa</a> <br  />
 SYS_SAGE_COMPONENT_CHIP -&gt; class <a class="el" href="class_chip.html">Chip</a> <br  />
 SYS_SAGE_COMPONENT_MEMORY -&gt; class <a class="el" href="class_memory.html">Memory</a> <br  />
 SYS_SAGE_COMPONENT_STORAGE -&gt; class <a class="el" href="class_storage.html">Storage</a> <br  />
 SYS_SAGE_COMPONENT_NODE -&gt; class <a class="el" href="class_node.html">Node</a> <br  />
 SYS_SAGE_COMPONENT_TOPOLOGY -&gt; class <a class="el" href="class_topology.html">Topology</a> </p><dl class="section return"><dt>Returns</dt><dd>componentType </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac6d7a80d187b4ec48f6bf6f084378ac0">componentType</a> </dd></dl>

</div>
</div>
<a id="a32113dd8489115c7e9a1696a8018e7a6" name="a32113dd8489115c7e9a1696a8018e7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32113dd8489115c7e9a1696a8018e7a6">&#9670;&#160;</a></span>GetComponentTypeStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Component::GetComponentTypeStr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns component type in human-readable string. <br  />
 SYS_SAGE_COMPONENT_NONE -&gt; "None" <br  />
 SYS_SAGE_COMPONENT_THREAD -&gt; "HW_thread" <br  />
 SYS_SAGE_COMPONENT_CORE -&gt; "Core" <br  />
 SYS_SAGE_COMPONENT_CACHE -&gt; "Cache" <br  />
 SYS_SAGE_COMPONENT_SUBDIVISION -&gt; "Subdivision" <br  />
 SYS_SAGE_COMPONENT_NUMA -&gt; "NUMA" <br  />
 SYS_SAGE_COMPONENT_CHIP -&gt; "Chip" <br  />
 SYS_SAGE_COMPONENT_MEMORY -&gt; "Memory" <br  />
 SYS_SAGE_COMPONENT_STORAGE -&gt; "Storage" <br  />
 SYS_SAGE_COMPONENT_NODE -&gt; "Node" <br  />
 SYS_SAGE_COMPONENT_TOPOLOGY -&gt; "Topology" </p><dl class="section return"><dt>Returns</dt><dd>string component type </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac6d7a80d187b4ec48f6bf6f084378ac0">componentType</a> </dd></dl>

</div>
</div>
<a id="ab46e74efe39f5226ee26ea2bdcdd9a6e" name="ab46e74efe39f5226ee26ea2bdcdd9a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46e74efe39f5226ee26ea2bdcdd9a6e">&#9670;&#160;</a></span>GetDataPathByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_data_path.html">DataPath</a> * Component::GetDataPathByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dp_type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a <a class="el" href="class_data_path.html">DataPath</a> * from the list of this component's data paths with matching type and orientation. <br  />
 The first match is returned &ndash; first SYS_SAGE_DATAPATH_OUTGOING are searched, then SYS_SAGE_DATAPATH_INCOMING. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dp_type</td><td>- <a class="el" href="class_data_path.html">DataPath</a> type (dp_type) to search for </td></tr>
    <tr><td class="paramname">orientation</td><td>- orientation of the <a class="el" href="class_data_path.html">DataPath</a> (SYS_SAGE_DATAPATH_OUTGOING or SYS_SAGE_DATAPATH_INCOMING or a logical or of these) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_data_path.html">DataPath</a> pointer to the found data path; NULL if nothing found. </dd></dl>

</div>
</div>
<a id="af29f5f5a1ee41d9b4d448482dc980a0e" name="af29f5f5a1ee41d9b4d448482dc980a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29f5f5a1ee41d9b4d448482dc980a0e">&#9670;&#160;</a></span>GetDataPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_data_path.html">DataPath</a> * &gt; * Component::GetDataPaths </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the DataPaths of this component according to their orientation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>- either SYS_SAGE_DATAPATH_OUTGOING or SYS_SAGE_DATAPATH_INCOMING </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to std::vector&lt;DataPath *&gt; with the result (dp_outgoing on SYS_SAGE_DATAPATH_OUTGOING, or dp_incoming on SYS_SAGE_DATAPATH_INCOMING, otherwise NULL) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a40517588f7b89687289bea681c6bfc79">dp_incoming</a> </dd>
<dd>
<a class="el" href="#a16af6908e826a8a2531f0a0e0d65d533">dp_outgoing</a> </dd></dl>

</div>
</div>
<a id="a5cededdc084c20d3f83e5d925a2c0c1c" name="a5cededdc084c20d3f83e5d925a2c0c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cededdc084c20d3f83e5d925a2c0c1c">&#9670;&#160;</a></span>GetDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::GetDepth </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>refresh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the depth (level) of a component in the topology. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refresh</td><td>- Boolean value, if true: recalculate the position (depth) of the component in the tree, if false, return the already stored value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The depth (level) of a component in the topology </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1f32d0806b8c40635e9d4224ed23dede">depth</a> </dd></dl>

</div>
</div>
<a id="aa8e0d9af5f40df0ccad6be3edde7dad0" name="aa8e0d9af5f40df0ccad6be3edde7dad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e0d9af5f40df0ccad6be3edde7dad0">&#9670;&#160;</a></span>GetId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::GetId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns id of the component. </p><dl class="section return"><dt>Returns</dt><dd>id </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7b51904172e22f13a182eb16b7de4aaf">id</a> </dd></dl>

</div>
</div>
<a id="a1a9d620ac8795ddec325b7e05707b9ef" name="a1a9d620ac8795ddec325b7e05707b9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9d620ac8795ddec325b7e05707b9ef">&#9670;&#160;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Component::GetName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns name of the component. </p><dl class="section return"><dt>Returns</dt><dd>name </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3f51bb245c415a384cd29c60f7b25ba2">name</a> </dd></dl>

</div>
</div>
<a id="a6a9bf890570d4308a42de352e804b821" name="a6a9bf890570d4308a42de352e804b821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9bf890570d4308a42de352e804b821">&#9670;&#160;</a></span>GetNthAncestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::GetNthAncestor </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves Nth ancestor, which resides N levels above. <br  />
 E.g. if n=1, the parent is retrieved; if n=2, the grandparent is retrieved and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- how many levels above the tree should be looked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestor residing N levels above. </dd></dl>

</div>
</div>
<a id="a763f9885feedbb76ce1c2a8632701f53" name="a763f9885feedbb76ce1c2a8632701f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763f9885feedbb76ce1c2a8632701f53">&#9670;&#160;</a></span>GetNthDescendents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; Component::GetNthDescendents </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a std::vector of <a class="el" href="class_component.html">Component</a> pointers, which reside 'depth' levels deeper. The tree is traversed in order as the children are stored in the std::vector. <br  />
 E.g. if depth=1, only children of the current are retrieved; if depth=2, only children of the children are retrieved.. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- how many levels down the tree should be looked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Component*&gt; with the results. </dd></dl>

</div>
</div>
<a id="ab0caa2be5b0a5a24e142cee7e7d27489" name="ab0caa2be5b0a5a24e142cee7e7d27489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0caa2be5b0a5a24e142cee7e7d27489">&#9670;&#160;</a></span>GetNthDescendents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::GetNthDescendents </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a std::vector of <a class="el" href="class_component.html">Component</a> pointers, which reside 'depth' levels deeper. The tree is traversed in order as the children are stored in std::vector children. <br  />
 E.g. if depth=1, only children of the current are retrieved; if depth=2, only children of the children are retrieved.. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- how many levels down the tree should be looked </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, nothing will be pushed into the vector.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad23ffe1aa55edc8b50e39b0835cdc2cf" name="ad23ffe1aa55edc8b50e39b0835cdc2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23ffe1aa55edc8b50e39b0835cdc2cf">&#9670;&#160;</a></span>GetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::GetNumThreads </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OBSOLETE. Use int CountAllSubcomponentsByType(SYS_SAGE_COMPONENT_THREAD) instead. Returns the number of Components of type SYS_SAGE_COMPONENT_THREAD in the subtree. </p>

</div>
</div>
<a id="a877ef6f7e49b6d38019988b07a7ceb20" name="a877ef6f7e49b6d38019988b07a7ceb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877ef6f7e49b6d38019988b07a7ceb20">&#9670;&#160;</a></span>GetParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::GetParent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_component.html">Component</a> pointer to parent (or NULL if this component is the root) </p>

</div>
</div>
<a id="a75bba5b614c9a3056e14b462a60cce4b" name="a75bba5b614c9a3056e14b462a60cce4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bba5b614c9a3056e14b462a60cce4b">&#9670;&#160;</a></span>GetSubcomponentById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a> * Component::GetSubcomponentById </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the subtree to find a component with a matching id and componentType, i.e. looks for a certain component with a matching ID. The search is a DFS. The search starts with the calling component. <br  />
 Returns first occurence that matches these criteria. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_id</td><td>- the id to look for </td></tr>
    <tr><td class="paramname">_componentType</td><td>- the component type where to look for the id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_component.html">Component</a> * matching the criteria. Returns the first match. NULL if no match found </dd></dl>

</div>
</div>
<a id="a2ae40c45cfcdd838e9c703553a8a291c" name="a2ae40c45cfcdd838e9c703553a8a291c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae40c45cfcdd838e9c703553a8a291c">&#9670;&#160;</a></span>GetSubcomponentsByType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; Component::GetSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_componentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a std::vector of <a class="el" href="class_component.html">Component</a> pointers, which reside in the subtree and have a matching type. The tree is traversed DFS in order as the children are stored in the std::vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentType</td><td>- componentType </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Component*&gt; with the results. </dd></dl>

</div>
</div>
<a id="acceb7931c7ff2f553e62368e77430c60" name="acceb7931c7ff2f553e62368e77430c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceb7931c7ff2f553e62368e77430c60">&#9670;&#160;</a></span>GetSubcomponentsByType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::GetSubcomponentsByType </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>outArray</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>componentType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a std::vector of <a class="el" href="class_component.html">Component</a> pointers, which reside in the subtree and have a matching type. The tree is traversed DFS in order as the children are stored in each std::vector children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentType</td><td>- componentType </td></tr>
    <tr><td class="paramname">outArray</td><td>- output parameter (vector with results) <br  />
 An input is pointer to a std::vector&lt;Component *&gt;, in which the elements will be pushed. It must be allocated before the call (but does not have to be empty). <br  />
 The method pushes back the found elements &ndash; i.e. the elements(pointers) can be found in this array after the method returns. (If no found, the vector is not changed.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a132ff3a8d0a98d1d1bb113b9f91aec04" name="a132ff3a8d0a98d1d1bb113b9f91aec04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132ff3a8d0a98d1d1bb113b9f91aec04">&#9670;&#160;</a></span>GetSubtreeDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::GetSubtreeDepth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves maximal distance to a leaf (i.e. the depth of the subtree). <br  />
 0=leaf, 1=children are leaves, 2=at most children's children are leaves ..... </p><dl class="section return"><dt>Returns</dt><dd>maximal distance to a leaf </dd></dl>

</div>
</div>
<a id="a2be4dace6140a0de5f00d9d5ad189d59" name="a2be4dace6140a0de5f00d9d5ad189d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be4dace6140a0de5f00d9d5ad189d59">&#9670;&#160;</a></span>GetTopologySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::GetTopologySize </td>
          <td>(</td>
          <td class="paramtype">unsigned *</td>          <td class="paramname"><span class="paramname"><em>out_component_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *</td>          <td class="paramname"><span class="paramname"><em>out_dataPathSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates approximate memory footprint of the subtree of this element (including the relevant data paths). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_component_size</td><td>- output parameter (contains the footprint of the component tree elements); an already allocated unsigned * is the input, the value is expected to be 0 (the result is accumulated here) </td></tr>
    <tr><td class="paramname">out_dataPathSize</td><td>- output parameter (contains the footprint of the data-path graph elements); an already allocated unsigned * is the input, the value is expected to be 0 (the result is accumulated here) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total size in bytes </dd></dl>

</div>
</div>
<a id="aef5a4c2ebc326905c06556780411bf8b" name="aef5a4c2ebc326905c06556780411bf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5a4c2ebc326905c06556780411bf8b">&#9670;&#160;</a></span>InsertBetweenParentAndChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::InsertBetweenParentAndChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alreadyParentsChild</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts this component between a parent and one of its children. The parent component remains the parent, this <a class="el" href="class_component.html">Component</a> becomes a new child of the parent, and the specified child becomes this component's child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent component to which this component will be inserted as a child. </td></tr>
    <tr><td class="paramname">child</td><td>The child component that will become the child of this component and will remain a descendant of the original parent. </td></tr>
    <tr><td class="paramname">alreadyParentsChild</td><td>A boolean flag indicating whether this component is already a child of the parent. <br  />
 If true, the function assumes that this component is already present as a child of the parent and only needs to reassign the specified child. <br  />
 If false, the function will add this component as a new child of the parent after reassigning the specified child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; 1 if the child and parent are not child and parent in the component tree; 2 if the component tree is corrupt (parent is a parent of child but child is not in the parent's children list); 3 if the component tree is corrupt (parent is not a parent of child but child is in the parent's children list). </dd></dl>

</div>
</div>
<a id="abb0a58bc196e2a0d578fe2d7626e709a" name="abb0a58bc196e2a0d578fe2d7626e709a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0a58bc196e2a0d578fe2d7626e709a">&#9670;&#160;</a></span>InsertBetweenParentAndChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::InsertBetweenParentAndChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_component.html">Component</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>children</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alreadyParentsChild</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts this component between a parent and a (subset of) his children. The parent component remains parent, this <a class="el" href="class_component.html">Component</a> becomes a new child, and the children become parent's grandchildren. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent component to which this component will be inserted as a child. </td></tr>
    <tr><td class="paramname">children</td><td>A vector of child components that will become the children of this component and the grandchildren of the original parent. </td></tr>
    <tr><td class="paramname">alreadyParentsChild</td><td>A boolean flag indicating whether this component is already a child of the parent. <br  />
 If true, the function assumes that this component is already present as a child of the parent and only needs to reassign the specified children. <br  />
 If false, the function will add this component as a new child of the parent after reassigning the specified children. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success <br  />
 1 on incompatible parent-children components (one or more children are not parent's children); <br  />
 2 on corrupt component tree (parent is a parent of child but child is NOT in children list of parent); <br  />
 3 on corrupt component tree (parent is NOT a parent of child but child is in children list of parent) </dd></dl>

</div>
</div>
<a id="a8506f89d8714c3fe2a3e435b97b5544f" name="a8506f89d8714c3fe2a3e435b97b5544f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8506f89d8714c3fe2a3e435b97b5544f">&#9670;&#160;</a></span>InsertChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::InsertChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a Child component to this component (in the <a class="el" href="class_component.html">Component</a> Tree). The child pointer will be inserted at the end of std::vector of children (retrievable through <a class="el" href="#adbfab074ef1ad7f359f22eafb66b59dc">GetChildren()</a>, <a class="el" href="#ae747cc962324d0b1174bcab97efec34f">GetChild(int _id)</a> etc.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>- a pointer to a <a class="el" href="class_component.html">Component</a> (or any class instance that inherits from <a class="el" href="class_component.html">Component</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#adbfab074ef1ad7f359f22eafb66b59dc">GetChildren()</a> </dd>
<dd>
<a class="el" href="#ae747cc962324d0b1174bcab97efec34f">GetChild(int _id)</a> </dd></dl>

</div>
</div>
<a id="a6b7a769dc19d12ece34053a9b5294cc9" name="a6b7a769dc19d12ece34053a9b5294cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7a769dc19d12ece34053a9b5294cc9">&#9670;&#160;</a></span>PrintAllDataPathsInSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::PrintAllDataPathsInSubtree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints to stdout basic information about all DataPaths that go either from or to the components in the subtree. <br  />
 For each component, all outgoing and incoming DataPaths are printed, i.e. a <a class="el" href="class_data_path.html">DataPath</a> may be printed twice. </p>

</div>
</div>
<a id="ad1cc172d9c737b978ad30f64196e96f9" name="ad1cc172d9c737b978ad30f64196e96f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cc172d9c737b978ad30f64196e96f9">&#9670;&#160;</a></span>PrintSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::PrintSubtree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the whole subtree of this component (including the component itself) to stdout. The tree is printed in DFS order, so that the hierarchy can be easily seen. Each child is indented by "  ". For each component in the subtree, the following is printed: "&lt;string component type&gt; (name &lt;name&gt;) id &lt;id&gt; - children: &lt;num children&gt; </p>

</div>
</div>
<a id="a753b5c04b6fc79ff6ebcd89593b701f9" name="a753b5c04b6fc79ff6ebcd89593b701f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753b5c04b6fc79ff6ebcd89593b701f9">&#9670;&#160;</a></span>RemoveChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Component::RemoveChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the passed component from the list of children, without completely deleting (and deallocating) the child itself </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>- child to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>how many elements were deleted (normally, 0 or 1 should be possible) </dd></dl>

</div>
</div>
<a id="aed28cdfc91df0bac02b7fd3d8955d082" name="aed28cdfc91df0bac02b7fd3d8955d082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed28cdfc91df0bac02b7fd3d8955d082">&#9670;&#160;</a></span>SetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::SetName </td>
          <td>(</td>
          <td class="paramtype">string</td>          <td class="paramname"><span class="paramname"><em>_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets name of the component. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>- name of the component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3f51bb245c415a384cd29c60f7b25ba2">name</a> </dd></dl>

</div>
</div>
<a id="a18d4b870ab8f711d030d4a7f1291c42b" name="a18d4b870ab8f711d030d4a7f1291c42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d4b870ab8f711d030d4a7f1291c42b">&#9670;&#160;</a></span>SetParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Component::SetParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_component.html">Component</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a parent to the component. This is usually used when inserting a component in the tree (by calling InsertChild on the parent, and calling SetParent on the child). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>- a pointer to a <a class="el" href="class_component.html">Component</a> (or any class instance that inherits from <a class="el" href="class_component.html">Component</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8506f89d8714c3fe2a3e435b97b5544f">InsertChild()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a17c49e18fd0a5e4ab6000844a5f41645" name="a17c49e18fd0a5e4ab6000844a5f41645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c49e18fd0a5e4ab6000844a5f41645">&#9670;&#160;</a></span>attrib</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, void*&gt; Component::attrib</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A map for storing arbitrary pieces of information or data.</p><ul>
<li>The <code>key</code> denotes the name of the attribute.</li>
<li>The <code>value</code> points to the data, stored as a <code>void*</code>.</li>
</ul>
<p>This data structure is designed to store a wide variety of data types by utilizing pointers to void. Due to its flexibility, it is essential to manage the types and memory allocation/deallocation carefully to avoid issues such as memory leaks or undefined behavior.</p>
<p>Usage:</p>
<ol type="1">
<li>Adding a new key-value pair:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span>* value = <span class="keyword">new</span> int(42); <span class="comment">// Dynamically allocate memory for the value</span></div>
<div class="line"><a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>[key] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(value); <span class="comment">// Store the value in the map</span></div>
<div class="ttc" id="aclass_component_html_a17c49e18fd0a5e4ab6000844a5f41645"><div class="ttname"><a href="#a17c49e18fd0a5e4ab6000844a5f41645">Component::attrib</a></div><div class="ttdeci">std::map&lt; std::string, void * &gt; attrib</div><div class="ttdef"><b>Definition</b> Component.hpp:556</div></div>
</div><!-- fragment --><ol type="1">
<li>Retrieving data from an existing key:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.find(key) != <a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.end()) {</div>
<div class="line">    <span class="keywordtype">int</span>* retrievedValue = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>[key]);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value: &quot;</span> &lt;&lt; *retrievedValue &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Key not found.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Checking for the existence of a key:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.find(key) != <a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.end()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Key exists.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Key does not exist.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Removing a key-value pair and freeing memory:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.find(key) != <a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.end()) {</div>
<div class="line">    <span class="keywordtype">int</span>* value = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>[key]);</div>
<div class="line">    <span class="keyword">delete</span> value; <span class="comment">// Free the dynamically allocated memory</span></div>
<div class="line">    <a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.erase(key); <span class="comment">// Remove the key-value pair from the map</span></div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>Updating the value for an existing key:</li>
</ol>
<div class="fragment"><div class="line">std::string key = <span class="stringliteral">&quot;exampleKey&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.find(key) != <a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>.end()) {</div>
<div class="line">    <span class="keywordtype">int</span>* oldValue = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>[key]);</div>
<div class="line">    <span class="keyword">delete</span> oldValue; <span class="comment">// Free the old value</span></div>
<div class="line">    <span class="keywordtype">int</span>* newValue = <span class="keyword">new</span> int(100); <span class="comment">// Allocate new value</span></div>
<div class="line">    <a class="code hl_variable" href="#a17c49e18fd0a5e4ab6000844a5f41645">attrib</a>[key] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(newValue); <span class="comment">// Update the map</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note:</p><ul>
<li>Proper memory management is crucial when using <code>void*</code> pointers. Always ensure that dynamically allocated memory is freed when no longer needed.</li>
<li>Type safety is not enforced, so it is important to cast pointers to the correct type when retrieving values from the map. </li>
</ul>

</div>
</div>
<a id="a6c3106b9a8ba60fead5f7bf3430ab00f" name="a6c3106b9a8ba60fead5f7bf3430ab00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3106b9a8ba60fead5f7bf3430ab00f">&#9670;&#160;</a></span>children</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_component.html">Component</a>*&gt; Component::children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the list (std::vector) of pointers to children of the component in the component tree. </p>

</div>
</div>
<a id="ac6d7a80d187b4ec48f6bf6f084378ac0" name="ac6d7a80d187b4ec48f6bf6f084378ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d7a80d187b4ec48f6bf6f084378ac0">&#9670;&#160;</a></span>componentType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int Component::componentType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_component.html">Component</a> type of the component. The component type denotes of which class the instance is (Often the components are stored as Component*, even though they are a member of one of the child classes) <br  />
 This attribute is constant, set by the constructor, and READONLY. <br  />
 SYS_SAGE_COMPONENT_NONE -&gt; class <a class="el" href="class_component.html">Component</a> <br  />
 SYS_SAGE_COMPONENT_THREAD -&gt; class <a class="el" href="class_thread.html">Thread</a> <br  />
 SYS_SAGE_COMPONENT_CORE -&gt; class <a class="el" href="class_core.html">Core</a> <br  />
 SYS_SAGE_COMPONENT_CACHE -&gt; class <a class="el" href="class_cache.html">Cache</a> <br  />
 SYS_SAGE_COMPONENT_SUBDIVISION -&gt; class <a class="el" href="class_subdivision.html">Subdivision</a> <br  />
 SYS_SAGE_COMPONENT_NUMA -&gt; class <a class="el" href="class_numa.html">Numa</a> <br  />
 SYS_SAGE_COMPONENT_CHIP -&gt; class <a class="el" href="class_chip.html">Chip</a> <br  />
 SYS_SAGE_COMPONENT_MEMORY -&gt; class <a class="el" href="class_memory.html">Memory</a> <br  />
 SYS_SAGE_COMPONENT_STORAGE -&gt; class <a class="el" href="class_storage.html">Storage</a> <br  />
 SYS_SAGE_COMPONENT_NODE -&gt; class <a class="el" href="class_node.html">Node</a> <br  />
 SYS_SAGE_COMPONENT_TOPOLOGY -&gt; class <a class="el" href="class_topology.html">Topology</a> </p>

</div>
</div>
<a id="a9cc084b0920e318e25b82c78a9b6c9a3" name="a9cc084b0920e318e25b82c78a9b6c9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc084b0920e318e25b82c78a9b6c9a3">&#9670;&#160;</a></span>count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Component::count {-1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be used to represent multiple Components with the same properties. By default, it represents only 1 component, and is set to -1. </p>

</div>
</div>
<a id="a1f32d0806b8c40635e9d4224ed23dede" name="a1f32d0806b8c40635e9d4224ed23dede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f32d0806b8c40635e9d4224ed23dede">&#9670;&#160;</a></span>depth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Component::depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Depth (level) of the <a class="el" href="class_component.html">Component</a> in the <a class="el" href="class_component.html">Component</a> Tree </p>

</div>
</div>
<a id="a40517588f7b89687289bea681c6bfc79" name="a40517588f7b89687289bea681c6bfc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40517588f7b89687289bea681c6bfc79">&#9670;&#160;</a></span>dp_incoming</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_data_path.html">DataPath</a>*&gt; Component::dp_incoming</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains references to data paths that point to this component. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_data_path.html">DataPath</a> </dd></dl>

</div>
</div>
<a id="a16af6908e826a8a2531f0a0e0d65d533" name="a16af6908e826a8a2531f0a0e0d65d533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16af6908e826a8a2531f0a0e0d65d533">&#9670;&#160;</a></span>dp_outgoing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_data_path.html">DataPath</a>*&gt; Component::dp_outgoing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains references to data paths that point from this component. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_data_path.html">DataPath</a> </dd></dl>

</div>
</div>
<a id="a7b51904172e22f13a182eb16b7de4aaf" name="a7b51904172e22f13a182eb16b7de4aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b51904172e22f13a182eb16b7de4aaf">&#9670;&#160;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Component::id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numeric ID of the component. There is no requirement for uniqueness of the ID, however it is advised to have unique IDs at least in the realm of parent's children. Some tree search functions, which take the id as a search parameter search for first match, so the user is responsible to manage uniqueness in the realm of the search subtree (or should be aware of the consequences of not doing so). <a class="el" href="class_component.html">Component</a>'s ID is set by the constructor, and is retrieved via int <a class="el" href="#aa8e0d9af5f40df0ccad6be3edde7dad0">GetId()</a>; </p>

</div>
</div>
<a id="a3f51bb245c415a384cd29c60f7b25ba2" name="a3f51bb245c415a384cd29c60f7b25ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f51bb245c415a384cd29c60f7b25ba2">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string Component::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Name of the component (as a string). </p>

</div>
</div>
<a id="add189dc18ca4dd121d7dede5a0dbeab8" name="add189dc18ca4dd121d7dede5a0dbeab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add189dc18ca4dd121d7dede5a0dbeab8">&#9670;&#160;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_component.html">Component</a>* Component::parent { nullptr }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains pointer to the parent component in the component tree. If this component is the root, parent will be NULL. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/stepan/phd/repos/caps_sys-sage/src/<a class="el" href="_component_8hpp_source.html">Component.hpp</a></li>
<li>/Users/stepan/phd/repos/caps_sys-sage/src/<b>Component.cpp</b></li>
<li>/Users/stepan/phd/repos/caps_sys-sage/src/<b>xml_dump.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
