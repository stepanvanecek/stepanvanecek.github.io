<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sys-sage: sys-sage PAPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sys-sage
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">sys-sage PAPI</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md50"></a> </p>
<h1><a class="anchor" id="autotoc_md51"></a>
General Information</h1>
<p>The <em>sys-sage</em> library incorporates the **P**erformance **A**pplication **P**rogramming **I**nterface [1] (PAPI) to enable the integration of hardware performance counters on CPUs into the <em>sys-sage</em> topology. That way, the performance metrics gained through PAPI can be attributed directly to the relevant hardware components, thus allowing for the examination and interpretation of the performance metrics within the context of the hardware topology.</p>
<p>To enable this feature, use the <code>-DPAPI=on</code> flag when building the <em>sys-sage</em> library. Apart from PAPI itself, note that <code>hwloc</code> is required as a dependency. Please make sure that it's installed on your system and provide an XML file generated by <code>hwloc</code> (e.g. <code>lstopo topo.xml</code>) to <code>sys-sage::parseHwlocOutput</code>.</p>
<p>A link to the PAPI Wiki can be found <a href="https://github.com/icl-utk-edu/papi/wiki">here</a>.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
General Workflow</h1>
<p>The following diagram shows the overall workflow of the PAPI metrics collection and evaluation through <em>sys-sage</em>:</p>
<div class="image">
<img src="sys-sage_PAPI_workflow.png" alt=""/>
</div>
    <p>The green boxes correspond to the <em>sys-sage</em> API whereas the blue ones correspond to plain PAPI. In general, the creation and configuration of event sets remain with PAPI, while the performance monitoring is now managed through <em>sys-sage</em>.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
API overview</h1>
<p>In principle, <em>sys-sage</em> uses a <code><a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">sys_sage::Relation</a></code> object to capture the performance counter values and to simultaneously relate them to the hardware threads, which are of type <code><a class="el" href="classsys__sage_1_1_thread.html">sys_sage::Thread</a></code>, on which they have been monitored on. To realize the PAPI integration, wrapper functions are provided that envelop the underlying PAPI routine. They will behave <b>exactly</b> like the underlying PAPI routine, with the added logic of automatically handling the storage of the performance counter values within the <em>sys-sage</em> topology via relation management. The wrapper functions are</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">sys-sage wrapper   </th><th class="markdownTableHeadNone">corresponding PAPI routine    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::SS_PAPI_start</code>   </td><td class="markdownTableBodyNone"><code>PAPI_start</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::SS_PAPI_reset</code>   </td><td class="markdownTableBodyNone"><code>PAPI_reset</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::SS_PAPI_read</code>   </td><td class="markdownTableBodyNone"><code>PAPI_read</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::SS_PAPI_accum</code>   </td><td class="markdownTableBodyNone"><code>PAPI_accum</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::SS_PAPI_stop</code>   </td><td class="markdownTableBodyNone"><code>PAPI_stop</code>   </td></tr>
</table>
<p>In general, the <em>sys-sage</em> wrappers can coexist with plain PAPI and can therefore be used next to the PAPI routines. This extends to routines like <code>PAPI_create_eventset</code>, <code>PAPI_attach</code> and so on. However, the wrappers <code>SS_PAPI_start</code>, <code>SS_PAPI_reset</code> and <code>SS_PAPI_accum</code> <b>must</b> be used instead of <code>PAPI_start</code>, <code>PAPI_reset</code> and <code>PAPI_accum</code> respectively.</p>
<p>To access or display the performance metrics that are integrated into the <em>sys-sage</em> topology, the following functions are provided</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Routines to access &amp; display PAPI metrics    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::Relation::GetPAPImetric</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::Relation::GetAllPAPImetrics</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::Relation::PrintPAPImetrics</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::Relation::FindPAPIevents</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::Relation::GetCurrentEventSet</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::Relation::GetElapsedTime</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::Thread::GetPAPImetric</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::Thread::PrintPAPImetrics</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::Thread::GetPAPIrelation</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::Thread::FindPAPIrelations</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::Thread::FindPAPIeventSets</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sys_sage::Component::PrintPAPImetricsInSubtree</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sys_sage::Component::FindPAPIrelationsInSubtree</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md54"></a>
Going through an example</h1>
<p>For more sophisticated examples, please have a look at the <code>examples/</code> directory of the <em>sys-sage</em> repository. The examples include</p>
<ul>
<li><code>papi_basics.cpp</code>: Simple usage of <em>sys-sage</em> PAPI</li>
<li><code>papi_multithreading.cpp</code>: Exploring multihreading in <em>sys-sage</em> PAPI</li>
<li><code>papi_monitor_process.cpp</code>: Exploring third-party monitoring of another process in <em>sys-sage</em> PAPI</li>
<li><code>papi_migrate_cpus.cpp</code>: Showcase of performance monitoring on a thread that constantly migrates across CPUs</li>
</ul>
<p>A minimal example is provided below. Note that error handling has been left out for the sake of simplicity and clarity. All <em>sys-sage</em> PAPI wrappers have adopted the return error codes of PAPI. Please refer to PAPI's Wiki for the error codes and to the documentation of the wrappers themselves for more information.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsys__sage_1_1_node.html">sys_sage::Node</a> *node = <span class="keyword">new</span> <a class="code hl_class" href="classsys__sage_1_1_node.html">sys_sage::Node</a>;</div>
<div class="line">sys_sage::parseHwlocOutput(node, path_to_hwloc_xml);</div>
<div class="line"> </div>
<div class="line">PAPI_library_init(PAPI_VER_CURRENT);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> eventSet = PAPI_NULL;</div>
<div class="line">PAPI_create_eventset(&amp;eventSet);</div>
<div class="line">PAPI_add_event(eventSet, PAPI_TOT_INS);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsys__sage_1_1_relation.html">sys_sage::Relation</a> *metrics = <span class="keyword">nullptr</span>;</div>
<div class="line">sys_sage::SS_PAPI_start(eventSet, &amp;metrics);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// do some computation...</span></div>
<div class="line"> </div>
<div class="line">sys_sage::SS_PAPI_stop(metrics, node);</div>
<div class="line"> </div>
<div class="line">metrics-&gt;PrintPAPImetrics();</div>
<div class="line"> </div>
<div class="line">PAPI_cleanup_eventset(eventSet);</div>
<div class="line">PAPI_destroy_eventset(&amp;eventSet);</div>
<div class="line">PAPI_shutdown();</div>
<div class="ttc" id="aclasssys__sage_1_1_node_html"><div class="ttname"><a href="classsys__sage_1_1_node.html">sys_sage::Node</a></div><div class="ttdef"><b>Definition</b> Node.hpp:12</div></div>
<div class="ttc" id="aclasssys__sage_1_1_relation_html"><div class="ttname"><a href="classsys__sage_1_1_relation.html">sys_sage::Relation</a></div><div class="ttdoc">Abstract base class representing a multi-way connection among Components.</div><div class="ttdef"><b>Definition</b> Relation.hpp:48</div></div>
</div><!-- fragment --><p>First, the <em>sys-sage</em> topology is created by parsing the XML file that is gained through hwloc. The <code>node</code> component then points to the root of the topology. Afterwards, the PAPI library and an event set are initialized as usual.</p>
<p>Now, in order to attribute the performance counter values to the hardware components, the <em>sys-sage</em> library uses a relation to naturally link them together. For this purpose, a pointer of type <code><a class="el" href="classsys__sage_1_1_relation.html" title="Abstract base class representing a multi-way connection among Components.">sys_sage::Relation</a></code> is provided to <code>sys_sage::SS_PAPI_start</code>. Since <code>metrics</code> is <code>nullptr</code>, the <em>sys-sage</em> library will create a new relation object, which <code>metrics</code> will point to after the call to <code>sys_sage::SS_PAPI_start</code>. If it already points to a valid relation object, that object will be reused instead. Within the same call, the underlying <code>PAPI_start</code> routine will be used to start the event set. This will also bind the relation object to an event set. When bound to new event set, the relation object does not loose the metrics of the previous event set.</p>
<p>After some computation, the wrapper <code>sys_sage::SS_PAPI_stop</code> is called to stop the event set and to automatically integrate the performance counter values into the topology. After this call, the relation object is also unbinded from the event set. Information about the performance counter values and the associated hardware components can be obtained through the relation object or through the component tree. In this case, this information is simply printed to <code>stdout</code> using the relation object.</p>
<p>At the end, the event set is cleaned up and the PAPI library is shut down. Note that the PAPI related functions offered in the <em>sys-sage</em> API will not work if the PAPI library is shut down.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Implementation Details</h1>
<p>This section of the documentation is intended for more specific knowledge about the internal structure and functionality.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Naming Convention</h2>
<p>Let's provide some definitions:</p>
<ul>
<li>"software thread": a software abstraction of an independant execution stream within a process.</li>
<li>"hardware thread": an independant execution unit in hardware.</li>
<li>"CPU": the same as a hardware thread</li>
</ul>
<h2><a class="anchor" id="autotoc_md57"></a>
What happens under the hood?</h2>
<p>The wrappers <code>SS_PAPI_read</code>, <code>SS_PAPI_accum</code> and <code>SS_PAPI_stop</code> all follow a very similar strategy:</p>
<ol type="1">
<li>Based on the given event set, determine the events associated to it and store the event codes in a local array called <code>events</code>.</li>
<li>Perform the call to the underlying PAPI routine using a local array called <code>counters</code>.<ul>
<li><code>SS_PAPI_read</code> -&gt; <code>PAPI_read</code></li>
<li><code>SS_PAPI_accum</code> -&gt; <code>PAPI_accum</code></li>
<li><code>SS_PAPI_stop</code> -&gt; <code>PAPI_stop</code></li>
</ul>
</li>
<li><p class="startli">Depending on the event set, figure out to which hardware thread the counters belong to and find its ID. Here, we need to make a case destinction:</p><ul>
<li>If the event set has explicitely been attached to a hardware thread, simply query for the ID through PAPI.</li>
<li>If the event set has explicitely been attached to a software thread, get the last known hardware thread on which it was scheduled on by reading <code>/proc/&lt;tid&gt;/stat</code>.</li>
<li>Otherwise, the event set is implicitely attached to the current software thread, in which case we simply call <code>sched_getcpu()</code>.</li>
</ul>
<p class="startli">In the last two cases, the software thread can potentially migrate across multiple hardware threads through repeated re-scheduling. Since PAPI uses <code>perf_event_open</code> internally, the Linux kernel will preserve the intermediate performance counter values across context switches. To "keep
   track" of these hardware threads and to attribute the performance counter values to them, a relation object with the new relation category <code>RelationCategory::PAPI_Metrics</code> is used.</p>
</li>
<li>Together with the ID of the hardware thread, query for its handle in the <em>sys-sage</em> topology. If the hardware thread is not already contained in the <code>Relation</code> object, it will be added to it.</li>
<li>Store the values of <code>counters</code> into the <code>attrib</code> map of the relation object on a per-event basis, meaning that if the value <code>counters[i]</code> at index <code>i</code> corresponds to the event <code>events[i]</code>, we will have a key-value pair similar to <code>{ events[i], counters[i] }</code>. Note that the values are actually stored as entries of a datastructure and that the string representation of the event code is used as the actual key. More detail is given below.</li>
</ol>
<h2><a class="anchor" id="autotoc_md58"></a>
Multiple Performance Counter Readings</h2>
<p>We define a "performance counter reading" to be the act of fetching the current values of the performance counters. It may be triggered by a call to either <code>SS_PAPI_read</code>, <code>SS_PAPI_accum</code> or <code>SS_PAPI_stop</code>.</p>
<p>Now, the <em>sys-sage</em> library allows the user to store the results of multiple performance counter readings of the same event. To distinguish them from one another, timestamps have been introduced. A timestamp is always associated to the entire reading, meaning that performance counter values of different events share the same timestamp within the same reading. It is important to state that these timestamps are <b>not</b> guaranteed to be unique for every reading &ndash; although most likely they will &ndash; and in case of a collision, the value of the latter reading will be returned.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Rules for the Storage Mechanism of the Performance Counter Values</h2>
<p>For the purpose of simplicity, we will focus on single-event event sets in this section. Everything described here can be easily extended to multiple events.</p>
<p>Let's define the operations <em>READ</em>, <em>RESET</em> and <em>ACCUM</em>, which correspond to the respective PAPI routines. We have</p>
<ul>
<li><em>READ</em>: capture the perf current counter value and store it</li>
<li><em>RESET</em>: set the perf counter to 0</li>
<li><em>ACCUM</em>: capture the current value of the perf counter, add it to some data, and perform the <em>RESET</em> operation</li>
</ul>
<p>Furthermore, each entry of the datastructure containing the perf counter values can be either in the <em>permanent</em> or <em>temporary</em> mode (indicated by a parameter). If an entry is temporary, it may be overwritten by some new perf counter reading. If it is permanent, it may not be modified again, and therefore a new entry must be added to the datastructure.</p>
<p>Now, the rules are as follows:</p>
<ol type="1">
<li>If a <em>RESET</em> operation is followed by a <em>READ</em> operation, all temporary entries on all CPUs of that specific event will be deleted.</li>
<li>If there are no more entries in the datastructure of a CPU, that CPU will be removed from the relation.</li>
<li>The value extracted from a <em>READ</em> operation will be "split" among all CPUs whose latest entry is temporary and contains a value that stems from the latest reading.</li>
</ol>
<p>If $x$ is the value gained from a <em>READ</em> operation on CPU $a$ and $y$ is the sum of values of all CPUs in the relation that satisfy the above conditions, then the result $z := x - y$ is stored in an entry corresponding to CPU $a$.</p>
<ol type="1">
<li>The value extracted from an <em>ACCUM</em> operation will be "merged" with all CPUs whose latest entry is permanent and contains a value that stems from the latest reading.</li>
</ol>
<p>If $x$ is the value gained from an <em>ACCUM</em> operation on CPU $a$ and $y$ is the sum of values of all CPUs in the relation that satisfy the above conditions, then the result $z := x + y$ is stored in an entry corresponding to CPU $a$.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
References</h1>
<p><a class="anchor" id="1"></a>[1] Jagode H, Danalis A, Congiu G, Barry D, Castaldo A, Dongarra J. <b>Advancements of PAPI for the exascale generation.</b> <em>The International Journal of High Performance Computing Applications.</em> 2024;39(2):251-268. <a href="https://journals.sagepub.com/doi/10.1177/10943420241303884">doi:10.1177/10943420241303884</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
